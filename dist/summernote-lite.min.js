/*! Summernote v0.9.1 | (c) 2013- Hackerwins and contributors | MIT license */
import l from "jquery";
l.summernote = l.summernote || {
  lang: {}
};
l.extend(!0, l.summernote.lang, {
  "en-US": {
    font: {
      bold: "Bold",
      italic: "Italic",
      underline: "Underline",
      clear: "Remove Font Style",
      height: "Line Height",
      name: "Font Family",
      strikethrough: "Strikethrough",
      subscript: "Subscript",
      superscript: "Superscript",
      size: "Font Size",
      sizeunit: "Font Size Unit"
    },
    image: {
      image: "Picture",
      insert: "Insert Image",
      resizeFull: "Resize full",
      resizeHalf: "Resize half",
      resizeQuarter: "Resize quarter",
      resizeNone: "Original size",
      floatLeft: "Float Left",
      floatRight: "Float Right",
      floatNone: "Remove float",
      shapeRounded: "Shape: Rounded",
      shapeCircle: "Shape: Circle",
      shapeThumbnail: "Shape: Thumbnail",
      shapeNone: "Shape: None",
      dragImageHere: "Drag image or text here",
      dropImage: "Drop image or Text",
      selectFromFiles: "Select from files",
      maximumFileSize: "Maximum file size",
      maximumFileSizeError: "Maximum file size exceeded.",
      url: "Image URL",
      remove: "Remove Image",
      original: "Original"
    },
    video: {
      video: "Video",
      videoLink: "Video Link",
      insert: "Insert Video",
      url: "Video URL",
      providers: "(YouTube, Google Drive, Vimeo, Vine, Instagram, DailyMotion, Youku, Peertube)"
    },
    link: {
      link: "Link",
      insert: "Insert Link",
      unlink: "Unlink",
      edit: "Edit",
      textToDisplay: "Text to display",
      url: "To what URL should this link go?",
      openInNewWindow: "Open in new window"
    },
    table: {
      table: "Table",
      addRowAbove: "Add row above",
      addRowBelow: "Add row below",
      addColLeft: "Add column left",
      addColRight: "Add column right",
      delRow: "Delete row",
      delCol: "Delete column",
      delTable: "Delete table"
    },
    hr: {
      insert: "Insert Horizontal Rule"
    },
    style: {
      style: "Style",
      p: "Normal",
      blockquote: "Quote",
      pre: "Code",
      h1: "Header 1",
      h2: "Header 2",
      h3: "Header 3",
      h4: "Header 4",
      h5: "Header 5",
      h6: "Header 6"
    },
    lists: {
      unordered: "Unordered list",
      ordered: "Ordered list"
    },
    options: {
      help: "Help",
      fullscreen: "Full Screen",
      codeview: "Code View"
    },
    paragraph: {
      paragraph: "Paragraph",
      outdent: "Outdent",
      indent: "Indent",
      left: "Align left",
      center: "Align center",
      right: "Align right",
      justify: "Justify full"
    },
    color: {
      recent: "Recent Color",
      more: "More Color",
      background: "Background Color",
      foreground: "Text Color",
      transparent: "Transparent",
      setTransparent: "Set transparent",
      reset: "Reset",
      resetToDefault: "Reset to default",
      cpSelect: "Select"
    },
    shortcut: {
      shortcuts: "Keyboard shortcuts",
      close: "Close",
      textFormatting: "Text formatting",
      action: "Action",
      paragraphFormatting: "Paragraph formatting",
      documentStyle: "Document Style",
      extraKeys: "Extra keys"
    },
    help: {
      escape: "Escape",
      insertParagraph: "Insert Paragraph",
      undo: "Undo the last command",
      redo: "Redo the last command",
      tab: "Tab",
      untab: "Untab",
      bold: "Set a bold style",
      italic: "Set a italic style",
      underline: "Set a underline style",
      strikethrough: "Set a strikethrough style",
      removeFormat: "Clean a style",
      justifyLeft: "Set left align",
      justifyCenter: "Set center align",
      justifyRight: "Set right align",
      justifyFull: "Set full align",
      insertUnorderedList: "Toggle unordered list",
      insertOrderedList: "Toggle ordered list",
      outdent: "Outdent on current paragraph",
      indent: "Indent on current paragraph",
      formatPara: "Change current block's format as a paragraph(P tag)",
      formatH1: "Change current block's format as H1",
      formatH2: "Change current block's format as H2",
      formatH3: "Change current block's format as H3",
      formatH4: "Change current block's format as H4",
      formatH5: "Change current block's format as H5",
      formatH6: "Change current block's format as H6",
      insertHorizontalRule: "Insert horizontal rule",
      "linkDialog.show": "Show Link Dialog"
    },
    history: {
      undo: "Undo",
      redo: "Redo"
    },
    specialChar: {
      specialChar: "SPECIAL CHARACTERS",
      select: "Select Special characters"
    },
    output: {
      noSelection: "No Selection Made!"
    }
  }
});
const _t = ["sans-serif", "serif", "monospace", "cursive", "fantasy"];
function qt(i) {
  return l.inArray(i.toLowerCase(), _t) === -1 ? `'${i}'` : i;
}
function Ce() {
  const i = "mw", t = "20px";
  var n = document.createElement("canvas"), s = n.getContext("2d", { willReadFrequently: !0 });
  n.width = 40, n.height = 20, s.textAlign = "center", s.fillStyle = "black", s.textBaseline = "middle";
  function a(c, d) {
    s.clearRect(0, 0, 40, 20), s.font = t + " " + qt(c) + ', "' + d + '"', s.fillText(i, 40 / 2, 20 / 2);
    var h = s.getImageData(0, 0, 40, 20).data;
    return h.join("");
  }
  return (c) => {
    const d = c === "Comic Sans MS" ? "Courier New" : "Comic Sans MS";
    let h = a(d, d), u = a(c, d);
    return h !== u;
  };
}
const z = navigator.userAgent, yt = /MSIE|Trident/i.test(z);
let wt;
if (yt) {
  let i = /MSIE (\d+[.]\d+)/.exec(z);
  i && (wt = parseFloat(i[1])), i = /Trident\/.*rv:([0-9]{1,}[.0-9]{0,})/.exec(z), i && (wt = parseFloat(i[1]));
}
const J = /Edge\/\d+/.test(z), we = "ontouchstart" in window || navigator.MaxTouchPoints > 0 || navigator.msMaxTouchPoints > 0, xe = yt ? "DOMCharacterDataModified DOMSubtreeModified DOMNodeInserted" : "input", $ = {
  isMac: navigator.appVersion.indexOf("Mac") > -1,
  isMSIE: yt,
  isEdge: J,
  isFF: !J && /firefox/i.test(z),
  isPhantom: /PhantomJS/i.test(z),
  isWebkit: !J && /webkit/i.test(z),
  isChrome: !J && /chrome/i.test(z),
  isSafari: !J && /safari/i.test(z) && !/chrome/i.test(z),
  browserVersion: wt,
  isSupportTouch: we,
  isFontInstalled: Ce(),
  isW3CRangeSupport: !!document.createRange,
  inputEventName: xe,
  genericFontFamilies: _t,
  validFontName: qt
};
function ye(i) {
  return function(t) {
    return i === t;
  };
}
function Se(i, t) {
  return i === t;
}
function $e(i) {
  return function(t, e) {
    return t[i] === e[i];
  };
}
function Te() {
  return !0;
}
function Ee() {
  return !1;
}
function Ne(i) {
  return function() {
    return !i.apply(i, arguments);
  };
}
function Re(i, t) {
  return function(e) {
    return i(e) && t(e);
  };
}
function Ie(i) {
  return i;
}
function Pe(i, t) {
  return function() {
    return i[t].apply(i, arguments);
  };
}
let Gt = 0;
function Ae() {
  Gt = 0;
}
function Le(i) {
  const t = ++Gt + "";
  return i ? i + t : t;
}
function Fe(i) {
  const t = l(document);
  return i ? {
    top: i.top + t.scrollTop(),
    left: i.left + t.scrollLeft(),
    width: i.right - i.left,
    height: i.bottom - i.top
  } : {
    top: 0,
    left: 0,
    width: 0,
    height: 0
  };
}
function De(i) {
  const t = {};
  for (const e in i)
    Object.prototype.hasOwnProperty.call(i, e) && (t[i[e]] = e);
  return t;
}
function He(i, t) {
  return t = t || "", t + i.split(".").map(function(e) {
    return e.substring(0, 1).toUpperCase() + e.substring(1);
  }).join("");
}
function Me(i, t, e) {
  let o;
  return function() {
    const n = this, s = arguments, a = () => {
      o = null, e || i.apply(n, s);
    }, c = e && !o;
    clearTimeout(o), o = setTimeout(a, t), c && i.apply(n, s);
  };
}
function Be(i) {
  return /[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/gi.test(i);
}
const v = {
  eq: ye,
  eq2: Se,
  peq2: $e,
  ok: Te,
  fail: Ee,
  self: Ie,
  not: Ne,
  and: Re,
  invoke: Pe,
  resetUniqueId: Ae,
  uniqueId: Le,
  rect2bnd: Fe,
  invertObject: De,
  namespaceToCamel: He,
  debounce: Me,
  isValidUrl: Be
};
function Yt(i) {
  return i[0];
}
function xt(i) {
  return i[i.length - 1];
}
function ze(i) {
  return i.slice(0, i.length - 1);
}
function Zt(i) {
  return i.slice(1);
}
function Oe(i, t) {
  for (let e = 0, o = i.length; e < o; e++) {
    const n = i[e];
    if (t(n))
      return n;
  }
}
function Ue(i, t) {
  for (let e = 0, o = i.length; e < o; e++)
    if (!t(i[e]))
      return !1;
  return !0;
}
function Xt(i, t) {
  if (i && i.length && t) {
    if (i.indexOf)
      return i.indexOf(t) !== -1;
    if (i.contains)
      return i.contains(t);
  }
  return !1;
}
function je(i, t) {
  return t = t || v.self, i.reduce(function(e, o) {
    return e + t(o);
  }, 0);
}
function We(i) {
  const t = [], e = i.length;
  let o = -1;
  for (; ++o < e; )
    t[o] = i[o];
  return t;
}
function Ke(i) {
  return !i || !i.length;
}
function Ve(i, t) {
  return i.length ? Zt(i).reduce(function(o, n) {
    const s = xt(o);
    return t(xt(s), n) ? s[s.length] = n : o[o.length] = [n], o;
  }, [[Yt(i)]]) : [];
}
function _e(i) {
  const t = [];
  for (let e = 0, o = i.length; e < o; e++)
    i[e] && t.push(i[e]);
  return t;
}
function qe(i) {
  const t = [];
  for (let e = 0, o = i.length; e < o; e++)
    Xt(t, i[e]) || t.push(i[e]);
  return t;
}
function Ge(i, t) {
  if (i && i.length && t) {
    const e = i.indexOf(t);
    return e === -1 ? null : i[e + 1];
  }
  return null;
}
function Ye(i, t) {
  if (i && i.length && t) {
    const e = i.indexOf(t);
    return e === -1 ? null : i[e - 1];
  }
  return null;
}
const f = {
  head: Yt,
  last: xt,
  initial: ze,
  tail: Zt,
  prev: Ye,
  next: Ge,
  find: Oe,
  contains: Xt,
  all: Ue,
  sum: je,
  from: We,
  isEmpty: Ke,
  clusterBy: Ve,
  compact: _e,
  unique: qe
}, St = "Â ", Ze = "\uFEFF";
function M(i) {
  return i && l(i).hasClass("note-editable");
}
function Xe(i) {
  return i && l(i).hasClass("note-control-sizing");
}
function E(i) {
  return i = i.toUpperCase(), function(t) {
    return t && t.nodeName.toUpperCase() === i;
  };
}
function B(i) {
  return i && i.nodeType === 3;
}
function Qe(i) {
  return i && i.nodeType === 1;
}
function rt(i) {
  return i && /^BR|^IMG|^HR|^IFRAME|^BUTTON|^INPUT|^AUDIO|^VIDEO|^EMBED/.test(i.nodeName.toUpperCase());
}
function Z(i) {
  return M(i) ? !1 : i && /^DIV|^P|^LI|^H[1-7]/.test(i.nodeName.toUpperCase());
}
function Je(i) {
  return i && /^H[1-7]/.test(i.nodeName.toUpperCase());
}
const to = E("PRE"), $t = E("LI");
function eo(i) {
  return Z(i) && !$t(i);
}
const Tt = E("TABLE"), Qt = E("DATA");
function at(i) {
  return !Rt(i) && !Et(i) && !oo(i) && !Z(i) && !Tt(i) && !Nt(i) && !Qt(i);
}
function Et(i) {
  return i && /^UL|^OL/.test(i.nodeName.toUpperCase());
}
const oo = E("HR");
function Jt(i) {
  return i && /^TD|^TH/.test(i.nodeName.toUpperCase());
}
const Nt = E("BLOCKQUOTE");
function Rt(i) {
  return Jt(i) || Nt(i) || M(i);
}
const Bt = E("A");
function io(i) {
  return at(i) && !!ct(i, Z);
}
function no(i) {
  return at(i) && !ct(i, Z);
}
const so = E("BODY");
function ro(i, t) {
  return i.nextSibling === t || i.previousSibling === t;
}
function ao(i, t) {
  t = t || v.ok;
  const e = [];
  return i.previousSibling && t(i.previousSibling) && e.push(i.previousSibling), e.push(i), i.nextSibling && t(i.nextSibling) && e.push(i.nextSibling), e;
}
const lt = $.isMSIE && $.browserVersion < 11 ? "&nbsp;" : "<br>";
function F(i) {
  return B(i) ? i.nodeValue.length : i ? i.childNodes.length : 0;
}
function lo(i) {
  do
    if (i.firstElementChild === null || i.firstElementChild.innerHTML === "") break;
  while (i = i.firstElementChild);
  return Y(i);
}
function Y(i) {
  const t = F(i);
  return t === 0 || !B(i) && t === 1 && i.innerHTML === lt ? !0 : !!(f.all(i.childNodes, B) && i.innerHTML === "");
}
function zt(i) {
  !rt(i) && !F(i) && (i.innerHTML = lt);
}
function ct(i, t) {
  for (; i; ) {
    if (t(i))
      return i;
    if (M(i))
      break;
    i = i.parentNode;
  }
  return null;
}
function co(i, t) {
  for (i = i.parentNode; i && F(i) === 1; ) {
    if (t(i))
      return i;
    if (M(i))
      break;
    i = i.parentNode;
  }
  return null;
}
function j(i, t) {
  t = t || v.fail;
  const e = [];
  return ct(i, function(o) {
    return M(o) || e.push(o), t(o);
  }), e;
}
function ho(i, t) {
  const e = j(i);
  return f.last(e.filter(t));
}
function uo(i, t) {
  const e = j(i);
  for (let o = t; o; o = o.parentNode)
    if (e.indexOf(o) > -1) return o;
  return null;
}
function fo(i, t) {
  t = t || v.fail;
  const e = [];
  for (; i && !t(i); )
    e.push(i), i = i.previousSibling;
  return e;
}
function te(i, t) {
  t = t || v.fail;
  const e = [];
  for (; i && !t(i); )
    e.push(i), i = i.nextSibling;
  return e;
}
function po(i, t) {
  const e = [];
  return t = t || v.ok, function o(n) {
    i !== n && t(n) && e.push(n);
    for (let s = 0, a = n.childNodes.length; s < a; s++)
      o(n.childNodes[s]);
  }(i), e;
}
function mo(i, t) {
  const e = i.parentNode, o = l("<" + t + ">")[0];
  return e.insertBefore(o, i), o.appendChild(i), o;
}
function It(i, t) {
  const e = t.nextSibling;
  let o = t.parentNode;
  return e ? o.insertBefore(i, e) : o.appendChild(i), i;
}
function Pt(i, t, e) {
  return l.each(t, function(o, n) {
    !e && $t(i) && i.firstChild === null && Et(n) && i.appendChild(At("br")), i.appendChild(n);
  }), i;
}
function dt(i) {
  return i.offset === 0;
}
function et(i) {
  return i.offset === F(i.node);
}
function ee(i) {
  return dt(i) || et(i);
}
function oe(i, t) {
  for (; i && i !== t; ) {
    if (K(i) !== 0)
      return !1;
    i = i.parentNode;
  }
  return !0;
}
function ie(i, t) {
  if (!t)
    return !1;
  for (; i && i !== t; ) {
    if (K(i) !== F(i.parentNode) - 1)
      return !1;
    i = i.parentNode;
  }
  return !0;
}
function go(i, t) {
  return dt(i) && oe(i.node, t);
}
function bo(i, t) {
  return et(i) && ie(i.node, t);
}
function K(i) {
  let t = 0;
  for (; i = i.previousSibling; )
    t += 1;
  return t;
}
function ot(i) {
  return !!(i && i.childNodes && i.childNodes.length);
}
function ne(i, t) {
  let e, o;
  if (i.offset === 0) {
    if (M(i.node))
      return null;
    e = i.node.parentNode, o = K(i.node);
  } else ot(i.node) ? (e = i.node.childNodes[i.offset - 1], o = F(e)) : (e = i.node, o = t ? 0 : i.offset - 1);
  return {
    node: e,
    offset: o
  };
}
function se(i, t) {
  let e, o;
  if (F(i.node) === i.offset) {
    if (M(i.node))
      return null;
    let n = ae(i.node);
    n ? (e = n, o = 0) : (e = i.node.parentNode, o = K(i.node) + 1);
  } else ot(i.node) ? (e = i.node.childNodes[i.offset], o = 0) : (e = i.node, o = t ? F(i.node) : i.offset + 1);
  return {
    node: e,
    offset: o
  };
}
function re(i, t) {
  let e, o = 0;
  if (F(i.node) === i.offset) {
    if (M(i.node))
      return null;
    e = i.node.parentNode, o = K(i.node) + 1, M(e) && (e = i.node.nextSibling, o = 0);
  } else ot(i.node) ? (e = i.node.childNodes[i.offset], o = 0) : (e = i.node, o = t ? F(i.node) : i.offset + 1);
  return {
    node: e,
    offset: o
  };
}
function ae(i) {
  if (i.nextSibling && i.parent === i.nextSibling.parent)
    return B(i.nextSibling) ? i.nextSibling : ae(i.nextSibling);
}
function le(i, t) {
  return i.node === t.node && i.offset === t.offset;
}
function vo(i) {
  if (B(i.node) || !ot(i.node) || Y(i.node))
    return !0;
  const t = i.node.childNodes[i.offset - 1], e = i.node.childNodes[i.offset];
  return !!((!t || rt(t)) && (!e || rt(e)) || Tt(e));
}
function ko(i, t) {
  for (; i; ) {
    if (t(i))
      return i;
    i = ne(i);
  }
  return null;
}
function Co(i, t) {
  for (; i; ) {
    if (t(i))
      return i;
    i = se(i);
  }
  return null;
}
function wo(i) {
  if (!B(i.node))
    return !1;
  const t = i.node.nodeValue.charAt(i.offset - 1);
  return t && t !== " " && t !== St;
}
function xo(i) {
  if (!B(i.node))
    return !1;
  const t = i.node.nodeValue.charAt(i.offset - 1);
  return t === " " || t === St;
}
function yo(i, t, e, o) {
  let n = i;
  for (; n && n.node && (e(n), !le(n, t)); ) {
    const s = o && i.node !== n.node && t.node !== n.node;
    n = re(n, s);
  }
}
function So(i, t) {
  return j(t, v.eq(i)).map(K).reverse();
}
function $o(i, t) {
  let e = i;
  for (let o = 0, n = t.length; o < n; o++)
    e.childNodes.length <= t[o] ? e = e.childNodes[e.childNodes.length - 1] : e = e.childNodes[t[o]];
  return e;
}
function gt(i, t) {
  let e = t && t.isSkipPaddingBlankHTML;
  const o = t && t.isNotSplitEdgePoint, n = t && t.isDiscardEmptySplits;
  if (n && (e = !0), ee(i) && (B(i.node) || o)) {
    if (dt(i))
      return i.node;
    if (et(i))
      return i.node.nextSibling;
  }
  if (B(i.node))
    return i.node.splitText(i.offset);
  {
    const s = i.node.childNodes[i.offset];
    let a = te(s);
    const c = It(i.node.cloneNode(!1), i.node);
    return Pt(c, a), e || (zt(i.node), zt(c)), n && (Y(i.node) && tt(i.node), Y(c)) ? (tt(c), i.node.nextSibling) : c;
  }
}
function ce(i, t, e) {
  let o = j(t.node, v.eq(i));
  if (o.length) {
    if (o.length === 1)
      return gt(t, e);
  } else return null;
  if (o.length > 2) {
    let s = o.slice(0, o.length - 1).find((a) => a.nextSibling);
    if (s && t.offset != 0 && et(t)) {
      let a = s.nextSibling, c;
      a.nodeType == 1 ? (c = a.childNodes[0], o = j(c, v.eq(i)), t = {
        node: c,
        offset: 0
      }) : a.nodeType == 3 && !a.data.match(/[\n\r]/g) && (c = a, o = j(c, v.eq(i)), t = {
        node: c,
        offset: 0
      });
    }
  }
  return o.reduce(function(n, s) {
    return n === t.node && (n = gt(t, e)), gt({
      node: s,
      offset: n ? K(n) : F(s)
    }, e);
  });
}
function To(i, t) {
  const e = t ? Z : Rt, o = j(i.node, e), n = f.last(o) || i.node;
  let s, a;
  e(n) ? (s = o[o.length - 2], a = n) : (s = n, a = s.parentNode);
  let c = s && ce(s, i, {
    isSkipPaddingBlankHTML: t,
    isNotSplitEdgePoint: t
  });
  return !c && a === i.node && (c = i.node.childNodes[i.offset]), {
    rightNode: c,
    container: a
  };
}
function At(i) {
  return document.createElement(i);
}
function Eo(i) {
  return document.createTextNode(i);
}
function tt(i, t) {
  if (!i || !i.parentNode)
    return;
  if (i.removeNode)
    return i.removeNode(t);
  const e = i.parentNode;
  if (!t) {
    const o = [];
    for (let n = 0, s = i.childNodes.length; n < s; n++)
      o.push(i.childNodes[n]);
    for (let n = 0, s = o.length; n < s; n++)
      e.insertBefore(o[n], i);
  }
  e.removeChild(i);
}
function No(i, t) {
  for (; i && !(M(i) || !t(i)); ) {
    const e = i.parentNode;
    tt(i), i = e;
  }
}
function Ro(i, t) {
  if (i.nodeName.toUpperCase() === t.toUpperCase())
    return i;
  const e = At(t);
  return i.style.cssText && (e.style.cssText = i.style.cssText), Pt(e, f.from(i.childNodes)), It(e, i), tt(i), e;
}
const de = E("TEXTAREA");
function he(i, t) {
  const e = de(i[0]) ? i.val() : i.html();
  return t ? e.replace(/[\n\r]/g, "") : e;
}
function Io(i, t) {
  let e = he(i);
  if (t) {
    const o = /<(\/?)(\b(?!!)[^>\s]*)(.*?)(\s*\/?>)/g;
    e = e.replace(o, function(n, s, a) {
      a = a.toUpperCase();
      const c = /^DIV|^TD|^TH|^P|^LI|^H[1-7]/.test(a) && !!s, d = /^BLOCKQUOTE|^TABLE|^TBODY|^TR|^HR|^UL|^OL/.test(a);
      return n + (c || d ? `
` : "");
    }), e = e.trim();
  }
  return e;
}
function Po(i) {
  const t = l(i), e = t.offset(), o = t.outerHeight(!0);
  return {
    left: e.left,
    top: e.top + o
  };
}
function Ao(i, t) {
  Object.keys(t).forEach(function(e) {
    i.on(e, t[e]);
  });
}
function Lo(i, t) {
  Object.keys(t).forEach(function(e) {
    i.off(e, t[e]);
  });
}
function Fo(i) {
  return i && !B(i) && f.contains(i.classList, "note-styletag");
}
const r = {
  /** @property {String} NBSP_CHAR */
  NBSP_CHAR: St,
  /** @property {String} ZERO_WIDTH_NBSP_CHAR */
  ZERO_WIDTH_NBSP_CHAR: Ze,
  /** @property {String} blank */
  blank: lt,
  /** @property {String} emptyPara */
  emptyPara: `<p>${lt}</p>`,
  makePredByNodeName: E,
  isEditable: M,
  isControlSizing: Xe,
  isText: B,
  isElement: Qe,
  isVoid: rt,
  isPara: Z,
  isPurePara: eo,
  isHeading: Je,
  isInline: at,
  isBlock: v.not(at),
  isBodyInline: no,
  isBody: so,
  isParaInline: io,
  isPre: to,
  isList: Et,
  isTable: Tt,
  isData: Qt,
  isCell: Jt,
  isBlockquote: Nt,
  isBodyContainer: Rt,
  isAnchor: Bt,
  isDiv: E("DIV"),
  isLi: $t,
  isBR: E("BR"),
  isSpan: E("SPAN"),
  isB: E("B"),
  isU: E("U"),
  isS: E("S"),
  isI: E("I"),
  isImg: E("IMG"),
  isTextarea: de,
  deepestChildIsEmpty: lo,
  isEmpty: Y,
  isEmptyAnchor: v.and(Bt, Y),
  isClosestSibling: ro,
  withClosestSiblings: ao,
  nodeLength: F,
  isLeftEdgePoint: dt,
  isRightEdgePoint: et,
  isEdgePoint: ee,
  isLeftEdgeOf: oe,
  isRightEdgeOf: ie,
  isLeftEdgePointOf: go,
  isRightEdgePointOf: bo,
  prevPoint: ne,
  nextPoint: se,
  nextPointWithEmptyNode: re,
  isSamePoint: le,
  isVisiblePoint: vo,
  prevPointUntil: ko,
  nextPointUntil: Co,
  isCharPoint: wo,
  isSpacePoint: xo,
  walkPoint: yo,
  ancestor: ct,
  singleChildAncestor: co,
  listAncestor: j,
  lastAncestor: ho,
  listNext: te,
  listPrev: fo,
  listDescendant: po,
  commonAncestor: uo,
  wrap: mo,
  insertAfter: It,
  appendChildNodes: Pt,
  position: K,
  hasChildren: ot,
  makeOffsetPath: So,
  fromOffsetPath: $o,
  splitTree: ce,
  splitPoint: To,
  create: At,
  createText: Eo,
  remove: tt,
  removeWhile: No,
  replace: Ro,
  html: Io,
  value: he,
  posFromPlaceholder: Po,
  attachEvents: Ao,
  detachEvents: Lo,
  isCustomStyleTag: Fo
};
class Do {
  /**
   * @param {jQuery} $note
   * @param {Object} options
   */
  constructor(t, e) {
    this.$note = t, this.memos = {}, this.modules = {}, this.layoutInfo = {}, this.options = l.extend(!0, {}, e), l.summernote.ui = l.summernote.ui_template(this.options), this.ui = l.summernote.ui, this.initialize();
  }
  /**
   * create layout and initialize modules and other resources
   */
  initialize() {
    return this.layoutInfo = this.ui.createLayout(this.$note), this._initialize(), this.$note.hide(), this;
  }
  /**
   * destroy modules and other resources and remove layout
   */
  destroy() {
    this._destroy(), this.$note.removeData("summernote"), this.ui.removeLayout(this.$note, this.layoutInfo);
  }
  /**
   * destory modules and other resources and initialize it again
   */
  reset() {
    const t = this.isDisabled();
    this.code(r.emptyPara), this._destroy(), this._initialize(), t && this.disable();
  }
  _initialize() {
    this.options.id = v.uniqueId(l.now()), this.options.container = this.options.container || this.layoutInfo.editor;
    const t = l.extend({}, this.options.buttons);
    Object.keys(t).forEach((o) => {
      this.memo("button." + o, t[o]);
    });
    const e = l.extend({}, this.options.modules, l.summernote.plugins || {});
    Object.keys(e).forEach((o) => {
      this.module(o, e[o], !0);
    }), Object.keys(this.modules).forEach((o) => {
      this.initializeModule(o);
    });
  }
  _destroy() {
    Object.keys(this.modules).reverse().forEach((t) => {
      this.removeModule(t);
    }), Object.keys(this.memos).forEach((t) => {
      this.removeMemo(t);
    }), this.triggerEvent("destroy", this);
  }
  code(t) {
    const e = this.invoke("codeview.isActivated");
    if (t === void 0)
      return this.invoke("codeview.sync"), e ? this.layoutInfo.codable.val() : this.layoutInfo.editable.html();
    e ? this.invoke("codeview.sync", t) : this.layoutInfo.editable.html(t), this.$note.val(t), this.triggerEvent("change", t, this.layoutInfo.editable);
  }
  isDisabled() {
    return this.layoutInfo.editable.attr("contenteditable") === "false";
  }
  enable() {
    this.layoutInfo.editable.attr("contenteditable", !0), this.invoke("toolbar.activate", !0), this.triggerEvent("disable", !1), this.options.editing = !0;
  }
  disable() {
    this.invoke("codeview.isActivated") && this.invoke("codeview.deactivate"), this.layoutInfo.editable.attr("contenteditable", !1), this.options.editing = !1, this.invoke("toolbar.deactivate", !0), this.triggerEvent("disable", !0);
  }
  triggerEvent() {
    const t = f.head(arguments), e = f.tail(f.from(arguments)), o = this.options.callbacks[v.namespaceToCamel(t, "on")];
    o && o.apply(this.$note[0], e), this.$note.trigger("summernote." + t, e);
  }
  initializeModule(t) {
    const e = this.modules[t];
    e.shouldInitialize = e.shouldInitialize || v.ok, e.shouldInitialize() && (e.initialize && e.initialize(), e.events && r.attachEvents(this.$note, e.events));
  }
  module(t, e, o) {
    if (arguments.length === 1)
      return this.modules[t];
    this.modules[t] = new e(this), o || this.initializeModule(t);
  }
  removeModule(t) {
    const e = this.modules[t];
    e.shouldInitialize() && (e.events && r.detachEvents(this.$note, e.events), e.destroy && e.destroy()), delete this.modules[t];
  }
  memo(t, e) {
    if (arguments.length === 1)
      return this.memos[t];
    this.memos[t] = e;
  }
  removeMemo(t) {
    this.memos[t] && this.memos[t].destroy && this.memos[t].destroy(), delete this.memos[t];
  }
  /**
   * Some buttons need to change their visual style immediately once they get pressed
   */
  createInvokeHandlerAndUpdateState(t, e) {
    return (o) => {
      this.createInvokeHandler(t, e)(o), this.invoke("buttons.updateCurrentStyle");
    };
  }
  createInvokeHandler(t, e) {
    return (o) => {
      o.preventDefault();
      const n = l(o.target);
      this.invoke(t, e || n.closest("[data-value]").data("value"), n);
    };
  }
  invoke() {
    const t = f.head(arguments), e = f.tail(f.from(arguments)), o = t.split("."), n = o.length > 1, s = n && f.head(o), a = n ? f.last(o) : f.head(o), c = this.modules[s || "editor"];
    if (!s && this[a])
      return this[a].apply(this, e);
    if (c && c[a] && c.shouldInitialize())
      return c[a].apply(c, e);
  }
}
l.fn.extend({
  /**
   * Summernote API
   *
   * @param {Object|String}
   * @return {this}
   */
  summernote: function() {
    const i = typeof f.head(arguments), t = i === "string", e = i === "object", o = l.extend({}, l.summernote.options, e ? f.head(arguments) : {});
    o.langInfo = l.extend(!0, {}, l.summernote.lang["en-US"], l.summernote.lang[o.lang]), o.icons = l.extend(!0, {}, l.summernote.options.icons, o.icons), o.tooltip = o.tooltip === "auto" ? !$.isSupportTouch : o.tooltip, this.each((s, a) => {
      const c = l(a);
      if (!c.data("summernote")) {
        const d = new Do(c, o);
        c.data("summernote", d), c.data("summernote").triggerEvent("init", d.layoutInfo);
      }
    });
    const n = this.first();
    if (n.length) {
      const s = n.data("summernote");
      if (t)
        return s.invoke.apply(s, f.from(arguments));
      o.focus && s.invoke("editor.focus");
    }
    return this;
  }
});
function Ot(i, t) {
  let e = i.parentElement(), o;
  const n = document.body.createTextRange();
  let s;
  const a = f.from(e.childNodes);
  for (o = 0; o < a.length; o++)
    if (!r.isText(a[o])) {
      if (n.moveToElementText(a[o]), n.compareEndPoints("StartToStart", i) >= 0)
        break;
      s = a[o];
    }
  if (o !== 0 && r.isText(a[o - 1])) {
    const c = document.body.createTextRange();
    let d = null;
    c.moveToElementText(s || e), c.collapse(!s), d = s ? s.nextSibling : e.firstChild;
    const h = i.duplicate();
    h.setEndPoint("StartToStart", c);
    let u = h.text.replace(/[\r\n]/g, "").length;
    for (; u > d.nodeValue.length && d.nextSibling; )
      u -= d.nodeValue.length, d = d.nextSibling;
    d.nodeValue, t && d.nextSibling && r.isText(d.nextSibling) && u === d.nodeValue.length && (u -= d.nodeValue.length, d = d.nextSibling), e = d, o = u;
  }
  return {
    cont: e,
    offset: o
  };
}
function Ut(i) {
  const t = function(n, s) {
    let a, c;
    if (r.isText(n)) {
      const d = r.listPrev(n, v.not(r.isText)), h = f.last(d).previousSibling;
      a = h || n.parentNode, s += f.sum(f.tail(d), r.nodeLength), c = !h;
    } else {
      if (a = n.childNodes[s] || n, r.isText(a))
        return t(a, 0);
      s = 0, c = !1;
    }
    return {
      node: a,
      collapseToStart: c,
      offset: s
    };
  }, e = document.body.createTextRange(), o = t(i.node, i.offset);
  return e.moveToElementText(o.node), e.collapse(o.collapseToStart), e.moveStart("character", o.offset), e;
}
class T {
  constructor(t, e, o, n) {
    this.sc = t, this.so = e, this.ec = o, this.eo = n, this.isOnEditable = this.makeIsOn(r.isEditable), this.isOnList = this.makeIsOn(r.isList), this.isOnAnchor = this.makeIsOn(r.isAnchor), this.isOnCell = this.makeIsOn(r.isCell), this.isOnData = this.makeIsOn(r.isData);
  }
  // nativeRange: get nativeRange from sc, so, ec, eo
  nativeRange() {
    if ($.isW3CRangeSupport) {
      const t = document.createRange();
      return t.setStart(this.sc, this.so), t.setEnd(this.ec, this.ec.data ? Math.min(this.eo, this.ec.data.length) : this.eo), t;
    } else {
      const t = Ut({
        node: this.sc,
        offset: this.so
      });
      return t.setEndPoint("EndToEnd", Ut({
        node: this.ec,
        offset: this.eo
      })), t;
    }
  }
  getPoints() {
    return {
      sc: this.sc,
      so: this.so,
      ec: this.ec,
      eo: this.eo
    };
  }
  getStartPoint() {
    return {
      node: this.sc,
      offset: this.so
    };
  }
  getEndPoint() {
    return {
      node: this.ec,
      offset: this.eo
    };
  }
  /**
   * select update visible range
   */
  select() {
    const t = this.nativeRange();
    if ($.isW3CRangeSupport) {
      const e = document.getSelection();
      e.rangeCount > 0 && e.removeAllRanges(), e.addRange(t);
    } else
      t.select();
    return this;
  }
  /**
   * Moves the scrollbar to start container(sc) of current range
   *
   * @return {WrappedRange}
   */
  scrollIntoView(t) {
    const e = l(t).height();
    return t.scrollTop + e < this.sc.offsetTop && (t.scrollTop += Math.abs(t.scrollTop + e - this.sc.offsetTop)), this;
  }
  /**
   * @return {WrappedRange}
   */
  normalize() {
    const t = function(n, s) {
      if (!n || r.isVisiblePoint(n) && (!r.isEdgePoint(n) || r.isRightEdgePoint(n) && !s || r.isLeftEdgePoint(n) && s || r.isRightEdgePoint(n) && s && r.isVoid(n.node.nextSibling) || r.isLeftEdgePoint(n) && !s && r.isVoid(n.node.previousSibling) || r.isBlock(n.node) && r.isEmpty(n.node)))
        return n;
      const a = r.ancestor(n.node, r.isBlock);
      let c = !1;
      if (!c) {
        const u = r.prevPoint(n) || { node: null };
        c = (r.isLeftEdgePointOf(n, a) || r.isVoid(u.node)) && !s;
      }
      let d = !1;
      if (!d) {
        const u = r.nextPoint(n) || { node: null };
        d = (r.isRightEdgePointOf(n, a) || r.isVoid(u.node)) && s;
      }
      if (c || d) {
        if (r.isVisiblePoint(n))
          return n;
        s = !s;
      }
      return (s ? r.nextPointUntil(r.nextPoint(n), r.isVisiblePoint) : r.prevPointUntil(r.prevPoint(n), r.isVisiblePoint)) || n;
    }, e = t(this.getEndPoint(), !1), o = this.isCollapsed() ? e : t(this.getStartPoint(), !0);
    return new T(
      o.node,
      o.offset,
      e.node,
      e.offset
    );
  }
  /**
   * returns matched nodes on range
   *
   * @param {Function} [pred] - predicate function
   * @param {Object} [options]
   * @param {Boolean} [options.includeAncestor]
   * @param {Boolean} [options.fullyContains]
   * @return {Node[]}
   */
  nodes(t, e) {
    t = t || v.ok;
    const o = e && e.includeAncestor, n = e && e.fullyContains, s = this.getStartPoint(), a = this.getEndPoint(), c = [], d = [];
    return r.walkPoint(s, a, function(h) {
      if (r.isEditable(h.node))
        return;
      let u;
      n ? (r.isLeftEdgePoint(h) && d.push(h.node), r.isRightEdgePoint(h) && f.contains(d, h.node) && (u = h.node)) : o ? u = r.ancestor(h.node, t) : u = h.node, u && t(u) && c.push(u);
    }, !0), f.unique(c);
  }
  /**
   * returns commonAncestor of range
   * @return {Element} - commonAncestor
   */
  commonAncestor() {
    return r.commonAncestor(this.sc, this.ec);
  }
  /**
   * returns expanded range by pred
   *
   * @param {Function} pred - predicate function
   * @return {WrappedRange}
   */
  expand(t) {
    const e = r.ancestor(this.sc, t), o = r.ancestor(this.ec, t);
    if (!e && !o)
      return new T(this.sc, this.so, this.ec, this.eo);
    const n = this.getPoints();
    return e && (n.sc = e, n.so = 0), o && (n.ec = o, n.eo = r.nodeLength(o)), new T(
      n.sc,
      n.so,
      n.ec,
      n.eo
    );
  }
  /**
   * @param {Boolean} isCollapseToStart
   * @return {WrappedRange}
   */
  collapse(t) {
    return t ? new T(this.sc, this.so, this.sc, this.so) : new T(this.ec, this.eo, this.ec, this.eo);
  }
  /**
   * splitText on range
   */
  splitText() {
    const t = this.sc === this.ec, e = this.getPoints();
    return r.isText(this.ec) && !r.isEdgePoint(this.getEndPoint()) && this.ec.splitText(this.eo), r.isText(this.sc) && !r.isEdgePoint(this.getStartPoint()) && (e.sc = this.sc.splitText(this.so), e.so = 0, t && (e.ec = e.sc, e.eo = this.eo - this.so)), new T(
      e.sc,
      e.so,
      e.ec,
      e.eo
    );
  }
  /**
   * delete contents on range
   * @return {WrappedRange}
   */
  deleteContents() {
    if (this.isCollapsed())
      return this;
    const t = this.splitText(), e = t.nodes(null, {
      fullyContains: !0
    }), o = r.prevPointUntil(t.getStartPoint(), function(s) {
      return !f.contains(e, s.node);
    }), n = [];
    return l.each(e, function(s, a) {
      const c = a.parentNode;
      o.node !== c && r.nodeLength(c) === 1 && n.push(c), r.remove(a, !1);
    }), l.each(n, function(s, a) {
      r.remove(a, !1);
    }), new T(
      o.node,
      o.offset,
      o.node,
      o.offset
    ).normalize();
  }
  /**
   * makeIsOn: return isOn(pred) function
   */
  makeIsOn(t) {
    return function() {
      const e = r.ancestor(this.sc, t);
      return !!e && e === r.ancestor(this.ec, t);
    };
  }
  /**
   * @param {Function} pred
   * @return {Boolean}
   */
  isLeftEdgeOf(t) {
    if (!r.isLeftEdgePoint(this.getStartPoint()))
      return !1;
    const e = r.ancestor(this.sc, t);
    return e && r.isLeftEdgeOf(this.sc, e);
  }
  /**
   * returns whether range was collapsed or not
   */
  isCollapsed() {
    return this.sc === this.ec && this.so === this.eo;
  }
  /**
   * wrap inline nodes which children of body with paragraph
   *
   * @return {WrappedRange}
   */
  wrapBodyInlineWithPara() {
    if (r.isBodyContainer(this.sc) && r.isEmpty(this.sc))
      return this.sc.innerHTML = r.emptyPara, new T(this.sc.firstChild, 0, this.sc.firstChild, 0);
    const t = this.normalize();
    if (r.isParaInline(this.sc) || r.isPara(this.sc))
      return t;
    let e;
    if (r.isInline(t.sc)) {
      const o = r.listAncestor(t.sc, v.not(r.isInline));
      e = f.last(o), r.isInline(e) || (e = o[o.length - 2] || t.sc.childNodes[t.so]);
    } else
      e = t.sc.childNodes[t.so > 0 ? t.so - 1 : 0];
    if (e) {
      let o = r.listPrev(e, r.isParaInline).reverse();
      if (o = o.concat(r.listNext(e.nextSibling, r.isParaInline)), o.length) {
        const n = r.wrap(f.head(o), "p");
        r.appendChildNodes(n, f.tail(o));
      }
    }
    return this.normalize();
  }
  /**
   * insert node at current cursor
   *
   * @param {Node} node
   * @param {Boolean} doNotInsertPara - default is false, removes added <p> that's added if true
   * @return {Node}
   */
  insertNode(t, e = !1) {
    let o = this;
    (r.isText(t) || r.isInline(t)) && (o = this.wrapBodyInlineWithPara().deleteContents());
    const n = r.splitPoint(o.getStartPoint(), r.isInline(t));
    return n.rightNode ? (n.rightNode.parentNode.insertBefore(t, n.rightNode), r.isEmpty(n.rightNode) && (e || r.isPara(t)) && n.rightNode.parentNode.removeChild(n.rightNode)) : n.container.appendChild(t), t;
  }
  /**
   * insert html at current cursor
   */
  pasteHTML(t) {
    t = ((t || "") + "").trim();
    const e = l("<div></div>").html(t)[0];
    let o = f.from(e.childNodes);
    const n = this;
    let s = !1;
    return n.so >= 0 && (o = o.reverse(), s = !0), o = o.map(function(a) {
      return n.insertNode(a, !r.isInline(a));
    }), s && (o = o.reverse()), o;
  }
  /**
   * returns text in range
   *
   * @return {String}
   */
  toString() {
    const t = this.nativeRange();
    return $.isW3CRangeSupport ? t.toString() : t.text;
  }
  /**
   * returns range for word before cursor
   *
   * @param {Boolean} [findAfter] - find after cursor, default: false
   * @return {WrappedRange}
   */
  getWordRange(t) {
    let e = this.getEndPoint();
    if (!r.isCharPoint(e))
      return this;
    const o = r.prevPointUntil(e, function(n) {
      return !r.isCharPoint(n);
    });
    return t && (e = r.nextPointUntil(e, function(n) {
      return !r.isCharPoint(n);
    })), new T(
      o.node,
      o.offset,
      e.node,
      e.offset
    );
  }
  /**
   * returns range for words before cursor
   *
   * @param {Boolean} [findAfter] - find after cursor, default: false
   * @return {WrappedRange}
   */
  getWordsRange(t) {
    var e = this.getEndPoint(), o = function(s) {
      return !r.isCharPoint(s) && !r.isSpacePoint(s);
    };
    if (o(e))
      return this;
    var n = r.prevPointUntil(e, o);
    return t && (e = r.nextPointUntil(e, o)), new T(
      n.node,
      n.offset,
      e.node,
      e.offset
    );
  }
  /**
   * returns range for words before cursor that match with a Regex
   *
   * example:
   *  range: 'hi @Peter Pan'
   *  regex: '/@[a-z ]+/i'
   *  return range: '@Peter Pan'
   *
   * @param {RegExp} [regex]
   * @return {WrappedRange|null}
   */
  getWordsMatchRange(t) {
    var e = this.getEndPoint(), o = r.prevPointUntil(e, function(c) {
      if (!r.isCharPoint(c) && !r.isSpacePoint(c))
        return !0;
      var d = new T(
        c.node,
        c.offset,
        e.node,
        e.offset
      ), h = t.exec(d.toString());
      return h && h.index === 0;
    }), n = new T(
      o.node,
      o.offset,
      e.node,
      e.offset
    ), s = n.toString(), a = t.exec(s);
    return a && a[0].length === s.length ? n : null;
  }
  /**
   * create offsetPath bookmark
   *
   * @param {Node} editable
   */
  bookmark(t) {
    return {
      s: {
        path: r.makeOffsetPath(t, this.sc),
        offset: this.so
      },
      e: {
        path: r.makeOffsetPath(t, this.ec),
        offset: this.eo
      }
    };
  }
  /**
   * create offsetPath bookmark base on paragraph
   *
   * @param {Node[]} paras
   */
  paraBookmark(t) {
    return {
      s: {
        path: f.tail(r.makeOffsetPath(f.head(t), this.sc)),
        offset: this.so
      },
      e: {
        path: f.tail(r.makeOffsetPath(f.last(t), this.ec)),
        offset: this.eo
      }
    };
  }
  /**
   * getClientRects
   * @return {Rect[]}
   */
  getClientRects() {
    return this.nativeRange().getClientRects();
  }
}
const w = {
  /**
   * create Range Object From arguments or Browser Selection
   *
   * @param {Node} sc - start container
   * @param {Number} so - start offset
   * @param {Node} ec - end container
   * @param {Number} eo - end offset
   * @return {WrappedRange}
   */
  create: function(i, t, e, o) {
    if (arguments.length === 4)
      return new T(i, t, e, o);
    if (arguments.length === 2)
      return e = i, o = t, new T(i, t, e, o);
    {
      let n = this.createFromSelection();
      if (!n && arguments.length === 1) {
        let s = arguments[0];
        return r.isEditable(s) && (s = s.lastChild), this.createFromBodyElement(s, r.emptyPara === arguments[0].innerHTML);
      }
      return n;
    }
  },
  createFromBodyElement: function(i, t = !1) {
    var e = this.createFromNode(i);
    return e.collapse(t);
  },
  createFromSelection: function() {
    let i, t, e, o;
    if ($.isW3CRangeSupport) {
      const n = document.getSelection();
      if (!n || n.rangeCount === 0)
        return null;
      if (r.isBody(n.anchorNode))
        return null;
      const s = n.getRangeAt(0);
      i = s.startContainer, t = s.startOffset, e = s.endContainer, o = s.endOffset;
    } else {
      const n = document.selection.createRange(), s = n.duplicate();
      s.collapse(!1);
      const a = n;
      a.collapse(!0);
      let c = Ot(a, !0), d = Ot(s, !1);
      r.isText(c.node) && r.isLeftEdgePoint(c) && r.isTextNode(d.node) && r.isRightEdgePoint(d) && d.node.nextSibling === c.node && (c = d), i = c.cont, t = c.offset, e = d.cont, o = d.offset;
    }
    return new T(i, t, e, o);
  },
  /**
   * @method
   *
   * create WrappedRange from node
   *
   * @param {Node} node
   * @return {WrappedRange}
   */
  createFromNode: function(i) {
    let t = i, e = 0, o = i, n = r.nodeLength(o);
    return r.isVoid(t) && (e = r.listPrev(t).length - 1, t = t.parentNode), r.isBR(o) ? (n = r.listPrev(o).length - 1, o = o.parentNode) : r.isVoid(o) && (n = r.listPrev(o).length, o = o.parentNode), this.create(t, e, o, n);
  },
  /**
   * create WrappedRange from node after position
   *
   * @param {Node} node
   * @return {WrappedRange}
   */
  createFromNodeBefore: function(i) {
    return this.createFromNode(i).collapse(!0);
  },
  /**
   * create WrappedRange from node after position
   *
   * @param {Node} node
   * @return {WrappedRange}
   */
  createFromNodeAfter: function(i) {
    return this.createFromNode(i).collapse();
  },
  /**
   * @method
   *
   * create WrappedRange from bookmark
   *
   * @param {Node} editable
   * @param {Object} bookmark
   * @return {WrappedRange}
   */
  createFromBookmark: function(i, t) {
    const e = r.fromOffsetPath(i, t.s.path), o = t.s.offset, n = r.fromOffsetPath(i, t.e.path), s = t.e.offset;
    return new T(e, o, n, s);
  },
  /**
   * @method
   *
   * create WrappedRange from paraBookmark
   *
   * @param {Object} bookmark
   * @param {Node[]} paras
   * @return {WrappedRange}
   */
  createFromParaBookmark: function(i, t) {
    const e = i.s.offset, o = i.e.offset, n = r.fromOffsetPath(f.head(t), i.s.path), s = r.fromOffsetPath(f.last(t), i.e.path);
    return new T(n, e, s, o);
  }
}, R = {
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  ESCAPE: 27,
  SPACE: 32,
  DELETE: 46,
  // Arrow
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  // Number: 0-9
  NUM0: 48,
  NUM1: 49,
  NUM2: 50,
  NUM3: 51,
  NUM4: 52,
  NUM5: 53,
  NUM6: 54,
  NUM7: 55,
  NUM8: 56,
  // Alphabet: a-z
  B: 66,
  E: 69,
  I: 73,
  J: 74,
  K: 75,
  L: 76,
  R: 82,
  S: 83,
  U: 85,
  V: 86,
  Y: 89,
  Z: 90,
  SLASH: 191,
  LEFTBRACKET: 219,
  BACKSLASH: 220,
  RIGHTBRACKET: 221,
  // Navigation
  HOME: 36,
  END: 35,
  PAGEUP: 33,
  PAGEDOWN: 34
}, x = {
  /**
   * @method isEdit
   *
   * @param {Number} keyCode
   * @return {Boolean}
   */
  isEdit: (i) => f.contains([
    R.BACKSPACE,
    R.TAB,
    R.ENTER,
    R.SPACE,
    R.DELETE
  ], i),
  /**
   * @method isRemove
   *
   * @param {Number} keyCode
   * @return {Boolean}
   */
  isRemove: (i) => f.contains([
    R.BACKSPACE,
    R.DELETE
  ], i),
  /**
   * @method isMove
   *
   * @param {Number} keyCode
   * @return {Boolean}
   */
  isMove: (i) => f.contains([
    R.LEFT,
    R.UP,
    R.RIGHT,
    R.DOWN
  ], i),
  /**
   * @method isNavigation
   *
   * @param {Number} keyCode
   * @return {Boolean}
   */
  isNavigation: (i) => f.contains([
    R.HOME,
    R.END,
    R.PAGEUP,
    R.PAGEDOWN
  ], i),
  /**
   * @property {Object} nameFromCode
   * @property {String} nameFromCode.8 "BACKSPACE"
   */
  nameFromCode: v.invertObject(R),
  code: R
};
function Ho(i) {
  return l.Deferred((t) => {
    l.extend(new FileReader(), {
      onload: (e) => {
        const o = e.target.result;
        t.resolve(o);
      },
      onerror: (e) => {
        t.reject(e);
      }
    }).readAsDataURL(i);
  }).promise();
}
function Mo(i) {
  return l.Deferred((t) => {
    const e = l("<img>");
    e.one("load", () => {
      e.off("error abort"), t.resolve(e);
    }).one("error abort", () => {
      e.off("load").detach(), t.reject(e);
    }).css({
      display: "none"
    }).appendTo(document.body).attr("src", i);
  }).promise();
}
class Bo {
  constructor(t) {
    this.stack = [], this.stackOffset = -1, this.context = t, this.$editable = t.layoutInfo.editable, this.editable = this.$editable[0];
  }
  makeSnapshot() {
    const t = w.create(this.editable), e = { s: { path: [], offset: 0 }, e: { path: [], offset: 0 } };
    return {
      contents: this.$editable.html(),
      bookmark: t && t.isOnEditable() ? t.bookmark(this.editable) : e
    };
  }
  applySnapshot(t) {
    t.contents !== null && this.$editable.html(t.contents), t.bookmark !== null && w.createFromBookmark(this.editable, t.bookmark).select();
  }
  /**
  * @method rewind
  * Rewinds the history stack back to the first snapshot taken.
  * Leaves the stack intact, so that "Redo" can still be used.
  */
  rewind() {
    this.$editable.html() !== this.stack[this.stackOffset].contents && this.recordUndo(), this.stackOffset = 0, this.applySnapshot(this.stack[this.stackOffset]);
  }
  /**
  *  @method commit
  *  Resets history stack, but keeps current editor's content.
  */
  commit() {
    this.stack = [], this.stackOffset = -1, this.recordUndo();
  }
  /**
  * @method reset
  * Resets the history stack completely; reverting to an empty editor.
  */
  reset() {
    this.stack = [], this.stackOffset = -1, this.$editable.html(""), this.recordUndo();
  }
  /**
   * undo
   */
  undo() {
    this.$editable.html() !== this.stack[this.stackOffset].contents && this.recordUndo(), this.stackOffset > 0 && (this.stackOffset--, this.applySnapshot(this.stack[this.stackOffset]));
  }
  /**
   * redo
   */
  redo() {
    this.stack.length - 1 > this.stackOffset && (this.stackOffset++, this.applySnapshot(this.stack[this.stackOffset]));
  }
  /**
   * recorded undo
   */
  recordUndo() {
    this.stackOffset++, this.stack.length > this.stackOffset && (this.stack = this.stack.slice(0, this.stackOffset)), this.stack.push(this.makeSnapshot()), this.stack.length > this.context.options.historyLimit && (this.stack.shift(), this.stackOffset -= 1);
  }
}
class zo {
  /**
   * @method jQueryCSS
   *
   * [workaround] for old jQuery
   * passing an array of style properties to .css()
   * will result in an object of property-value pairs.
   * (compability with version < 1.9)
   *
   * @private
   * @param  {jQuery} $obj
   * @param  {Array} propertyNames - An array of one or more CSS properties.
   * @return {Object}
   */
  jQueryCSS(t, e) {
    const o = {};
    return l.each(e, (n, s) => {
      o[s] = t.css(s);
    }), o;
  }
  /**
   * returns style object from node
   *
   * @param {jQuery} $node
   * @return {Object}
   */
  fromNode(t) {
    const e = ["font-family", "font-size", "text-align", "list-style-type", "line-height"], o = this.jQueryCSS(t, e) || {}, n = t[0].style.fontSize || o["font-size"];
    return o["font-size"] = parseInt(n, 10), o["font-size-unit"] = n.match(/[a-z%]+$/), o;
  }
  /**
   * paragraph level style
   *
   * @param {WrappedRange} rng
   * @param {Object} styleInfo
   */
  stylePara(t, e) {
    l.each(t.nodes(r.isPara, {
      includeAncestor: !0
    }), (o, n) => {
      l(n).css(e);
    });
  }
  /**
   * insert and returns styleNodes on range.
   *
   * @param {WrappedRange} rng
   * @param {Object} [options] - options for styleNodes
   * @param {String} [options.nodeName] - default: `SPAN`
   * @param {Boolean} [options.expandClosestSibling] - default: `false`
   * @param {Boolean} [options.onlyPartialContains] - default: `false`
   * @return {Node[]}
   */
  styleNodes(t, e) {
    t = t.splitText();
    const o = e && e.nodeName || "SPAN", n = !!(e && e.expandClosestSibling), s = !!(e && e.onlyPartialContains);
    if (t.isCollapsed())
      return [t.insertNode(r.create(o))];
    let a = r.makePredByNodeName(o);
    const c = t.nodes(r.isText, {
      fullyContains: !0
    }).map((d) => r.singleChildAncestor(d, a) || r.wrap(d, o));
    if (n) {
      if (s) {
        const d = t.nodes();
        a = v.and(a, (h) => f.contains(d, h));
      }
      return c.map((d) => {
        const h = r.withClosestSiblings(d, a), u = f.head(h), p = f.tail(h);
        return l.each(p, (k, C) => {
          r.appendChildNodes(u, C.childNodes), r.remove(C);
        }), f.head(h);
      });
    } else
      return c;
  }
  /**
   * get current style on cursor
   *
   * @param {WrappedRange} rng
   * @return {Object} - object contains style properties.
   */
  current(t) {
    const e = l(r.isElement(t.sc) ? t.sc : t.sc.parentNode);
    let o = this.fromNode(e);
    try {
      o = l.extend(o, {
        "font-bold": document.queryCommandState("bold") ? "bold" : "normal",
        "font-italic": document.queryCommandState("italic") ? "italic" : "normal",
        "font-underline": document.queryCommandState("underline") ? "underline" : "normal",
        "font-subscript": document.queryCommandState("subscript") ? "subscript" : "normal",
        "font-superscript": document.queryCommandState("superscript") ? "superscript" : "normal",
        "font-strikethrough": document.queryCommandState("strikethrough") ? "strikethrough" : "normal",
        "font-family": document.queryCommandValue("fontname") || o["font-family"]
      });
    } catch {
    }
    if (!t.isOnList())
      o["list-style"] = "none";
    else {
      const a = ["circle", "disc", "disc-leading-zero", "square"].indexOf(o["list-style-type"]) > -1;
      o["list-style"] = a ? "unordered" : "ordered";
    }
    const n = r.ancestor(t.sc, r.isPara);
    if (n && n.style["line-height"])
      o["line-height"] = n.style.lineHeight;
    else {
      const s = parseInt(o["line-height"], 10) / parseInt(o["font-size"], 10);
      o["line-height"] = s.toFixed(1);
    }
    return o.anchor = t.isOnAnchor() && r.ancestor(t.sc, r.isAnchor), o.ancestors = r.listAncestor(t.sc, r.isEditable), o.range = t, o;
  }
}
class ue {
  /**
   * toggle ordered list
   */
  insertOrderedList(t) {
    this.toggleList("OL", t);
  }
  /**
   * toggle unordered list
   */
  insertUnorderedList(t) {
    this.toggleList("UL", t);
  }
  /**
   * indent
   */
  indent(t) {
    const e = w.create(t).wrapBodyInlineWithPara(), o = e.nodes(r.isPara, { includeAncestor: !0 }), n = f.clusterBy(o, v.peq2("parentNode"));
    l.each(n, (s, a) => {
      const c = f.head(a);
      if (r.isLi(c)) {
        const d = this.findList(c.previousSibling);
        d ? a.map((h) => d.appendChild(h)) : (this.wrapList(a, c.parentNode.nodeName), a.map((h) => h.parentNode).map((h) => this.appendToPrevious(h)));
      } else
        l.each(a, (d, h) => {
          l(h).css("marginLeft", (u, p) => (parseInt(p, 10) || 0) + 25);
        });
    }), e.select();
  }
  /**
   * outdent
   */
  outdent(t) {
    const e = w.create(t).wrapBodyInlineWithPara(), o = e.nodes(r.isPara, { includeAncestor: !0 }), n = f.clusterBy(o, v.peq2("parentNode"));
    l.each(n, (s, a) => {
      const c = f.head(a);
      r.isLi(c) ? this.releaseList([a]) : l.each(a, (d, h) => {
        l(h).css("marginLeft", (u, p) => (p = parseInt(p, 10) || 0, p > 25 ? p - 25 : ""));
      });
    }), e.select();
  }
  /**
   * toggle list
   *
   * @param {String} listName - OL or UL
   */
  toggleList(t, e) {
    const o = w.create(e).wrapBodyInlineWithPara();
    let n = o.nodes(r.isPara, { includeAncestor: !0 });
    const s = o.paraBookmark(n), a = f.clusterBy(n, v.peq2("parentNode"));
    if (f.find(n, r.isPurePara)) {
      let c = [];
      l.each(a, (d, h) => {
        c = c.concat(this.wrapList(h, t));
      }), n = c;
    } else {
      const c = o.nodes(r.isList, {
        includeAncestor: !0
      }).filter((d) => d.nodeName !== t);
      c.length ? l.each(c, (d, h) => {
        r.replace(h, t);
      }) : n = this.releaseList(a, !0);
    }
    w.createFromParaBookmark(s, n).select();
  }
  /**
   * @param {Node[]} paras
   * @param {String} listName
   * @return {Node[]}
   */
  wrapList(t, e) {
    const o = f.head(t), n = f.last(t), s = r.isList(o.previousSibling) && o.previousSibling, a = r.isList(n.nextSibling) && n.nextSibling, c = s || r.insertAfter(r.create(e || "UL"), n);
    return t = t.map((d) => r.isPurePara(d) ? r.replace(d, "LI") : d), r.appendChildNodes(c, t, !0), a && (r.appendChildNodes(c, f.from(a.childNodes), !0), r.remove(a)), t;
  }
  /**
   * @method releaseList
   *
   * @param {Array[]} clustereds
   * @param {Boolean} isEscapseToBody
   * @return {Node[]}
   */
  releaseList(t, e) {
    let o = [];
    return l.each(t, (n, s) => {
      const a = f.head(s), c = f.last(s), d = e ? r.lastAncestor(a, r.isList) : a.parentNode, h = d.parentNode;
      if (d.parentNode.nodeName === "LI")
        s.map((u) => {
          const p = this.findNextSiblings(u);
          h.nextSibling ? h.parentNode.insertBefore(u, h.nextSibling) : h.parentNode.appendChild(u), p.length && (this.wrapList(p, d.nodeName), u.appendChild(p[0].parentNode));
        }), d.children.length === 0 && h.removeChild(d), h.childNodes.length === 0 && h.parentNode.removeChild(h);
      else {
        const u = d.childNodes.length > 1 ? r.splitTree(
          d,
          {
            node: c.parentNode,
            offset: r.position(c) + 1
          },
          {
            isSkipPaddingBlankHTML: !0
          }
        ) : null, p = r.splitTree(
          d,
          {
            node: a.parentNode,
            offset: r.position(a)
          },
          {
            isSkipPaddingBlankHTML: !0
          }
        );
        s = e ? r.listDescendant(p, r.isLi) : f.from(p.childNodes).filter(r.isLi), (e || !r.isList(d.parentNode)) && (s = s.map((C) => r.replace(C, "P"))), l.each(f.from(s).reverse(), (C, N) => {
          r.insertAfter(N, d);
        });
        const k = f.compact([d, p, u]);
        l.each(k, (C, N) => {
          const L = [N].concat(r.listDescendant(N, r.isList));
          l.each(L.reverse(), (G, m) => {
            r.nodeLength(m) || r.remove(m, !0);
          });
        });
      }
      o = o.concat(s);
    }), o;
  }
  /**
   * @method appendToPrevious
   *
   * Appends list to previous list item, if
   * none exist it wraps the list in a new list item.
   *
   * @param {HTMLNode} ListItem
   * @return {HTMLNode}
   */
  appendToPrevious(t) {
    return t.previousSibling ? r.appendChildNodes(t.previousSibling, [t]) : this.wrapList([t], "LI");
  }
  /**
   * @method findList
   *
   * Finds an existing list in list item
   *
   * @param {HTMLNode} ListItem
   * @return {Array[]}
   */
  findList(t) {
    return t ? f.find(t.children, (e) => ["OL", "UL"].indexOf(e.nodeName) > -1) : null;
  }
  /**
   * @method findNextSiblings
   *
   * Finds all list item siblings that follow it
   *
   * @param {HTMLNode} ListItem
   * @return {HTMLNode}
   */
  findNextSiblings(t) {
    const e = [];
    for (; t.nextSibling; )
      e.push(t.nextSibling), t = t.nextSibling;
    return e;
  }
}
class Oo {
  constructor(t) {
    this.bullet = new ue(), this.options = t.options;
  }
  /**
   * insert tab
   *
   * @param {WrappedRange} rng
   * @param {Number} tabsize
   */
  insertTab(t, e) {
    const o = r.createText(new Array(e + 1).join(r.NBSP_CHAR));
    t = t.deleteContents(), t.insertNode(o, !0), t = w.create(o, e), t.select();
  }
  /**
   * insert paragraph
   *
   * @param {jQuery} $editable
   * @param {WrappedRange} rng Can be used in unit tests to "mock" the range
   *
   * blockquoteBreakingLevel
   *   0 - No break, the new paragraph remains inside the quote
   *   1 - Break the first blockquote in the ancestors list
   *   2 - Break all blockquotes, so that the new paragraph is not quoted (this is the default)
   */
  insertParagraph(t, e) {
    e = e || w.create(t), e = e.deleteContents(), e = e.wrapBodyInlineWithPara();
    const o = r.ancestor(e.sc, r.isPara);
    let n;
    if (o)
      if (r.isLi(o) && (r.isEmpty(o) || r.deepestChildIsEmpty(o))) {
        this.bullet.toggleList(o.parentNode.nodeName);
        return;
      } else {
        let s = null;
        if (this.options.blockquoteBreakingLevel === 1 ? s = r.ancestor(o, r.isBlockquote) : this.options.blockquoteBreakingLevel === 2 && (s = r.lastAncestor(o, r.isBlockquote)), s) {
          n = l(r.emptyPara)[0], r.isRightEdgePoint(e.getStartPoint()) && r.isBR(e.sc.nextSibling) && l(e.sc.nextSibling).remove();
          const a = r.splitTree(s, e.getStartPoint(), { isDiscardEmptySplits: !0 });
          a ? a.parentNode.insertBefore(n, a) : r.insertAfter(n, s);
        } else {
          n = r.splitTree(o, e.getStartPoint());
          let a = r.listDescendant(o, r.isEmptyAnchor);
          a = a.concat(r.listDescendant(n, r.isEmptyAnchor)), l.each(a, (c, d) => {
            r.remove(d);
          }), (r.isHeading(n) || r.isPre(n) || r.isCustomStyleTag(n)) && r.isEmpty(n) && (n = r.replace(n, "p"));
        }
      }
    else {
      const s = e.sc.childNodes[e.so];
      n = l(r.emptyPara)[0], s ? e.sc.insertBefore(n, s) : e.sc.appendChild(n);
    }
    w.create(n, 0).normalize().select().scrollIntoView(t);
  }
}
const b = function(i, t, e, o) {
  const n = { colPos: 0, rowPos: 0 }, s = [], a = [];
  function c() {
    !i || !i.tagName || i.tagName.toLowerCase() !== "td" && i.tagName.toLowerCase() !== "th" || (n.colPos = i.cellIndex, !(!i.parentElement || !i.parentElement.tagName || i.parentElement.tagName.toLowerCase() !== "tr") && (n.rowPos = i.parentElement.rowIndex));
  }
  function d(m, g, y, S, O, D, U) {
    const H = {
      baseRow: y,
      baseCell: S,
      isRowSpan: O,
      isColSpan: D,
      isVirtual: U
    };
    s[m] || (s[m] = []), s[m][g] = H;
  }
  function h(m, g, y, S) {
    return {
      baseCell: m.baseCell,
      action: g,
      virtualTable: {
        rowIndex: y,
        cellIndex: S
      }
    };
  }
  function u(m, g) {
    if (!s[m] || !s[m][g])
      return g;
    let y = g;
    for (; s[m][y]; )
      if (y++, !s[m][y])
        return y;
  }
  function p(m, g) {
    const y = u(m.rowIndex, g.cellIndex), S = g.colSpan > 1, O = g.rowSpan > 1, D = m.rowIndex === n.rowPos && g.cellIndex === n.colPos;
    d(m.rowIndex, y, m, g, O, S, !1);
    const U = g.attributes.rowSpan ? parseInt(g.attributes.rowSpan.value, 10) : 0;
    if (U > 1)
      for (let P = 1; P < U; P++) {
        const _ = m.rowIndex + P;
        k(_, y, g, D), d(_, y, m, g, !0, S, !0);
      }
    const H = g.attributes.colSpan ? parseInt(g.attributes.colSpan.value, 10) : 0;
    if (H > 1)
      for (let P = 1; P < H; P++) {
        const _ = u(m.rowIndex, y + P);
        k(m.rowIndex, _, g, D), d(m.rowIndex, _, m, g, O, !0, !0);
      }
  }
  function k(m, g, y, S) {
    m === n.rowPos && n.colPos >= y.cellIndex && y.cellIndex <= g && !S && n.colPos++;
  }
  function C() {
    const m = o.rows;
    for (let g = 0; g < m.length; g++) {
      const y = m[g].cells;
      for (let S = 0; S < y.length; S++)
        p(m[g], y[S]);
    }
  }
  function N(m) {
    switch (t) {
      case b.where.Column:
        if (m.isColSpan)
          return b.resultAction.SubtractSpanCount;
        break;
      case b.where.Row:
        if (!m.isVirtual && m.isRowSpan)
          return b.resultAction.AddCell;
        if (m.isRowSpan)
          return b.resultAction.SubtractSpanCount;
        break;
    }
    return b.resultAction.RemoveCell;
  }
  function L(m) {
    switch (t) {
      case b.where.Column:
        if (m.isColSpan)
          return b.resultAction.SumSpanCount;
        if (m.isRowSpan && m.isVirtual)
          return b.resultAction.Ignore;
        break;
      case b.where.Row:
        if (m.isRowSpan)
          return b.resultAction.SumSpanCount;
        if (m.isColSpan && m.isVirtual)
          return b.resultAction.Ignore;
        break;
    }
    return b.resultAction.AddCell;
  }
  function G() {
    c(), C();
  }
  this.getActionList = function() {
    const m = t === b.where.Row ? n.rowPos : -1, g = t === b.where.Column ? n.colPos : -1;
    let y = 0, S = !0;
    for (; S; ) {
      const O = m >= 0 ? m : y, D = g >= 0 ? g : y, U = s[O];
      if (!U)
        return S = !1, a;
      const H = U[D];
      if (!H)
        return S = !1, a;
      let P = b.resultAction.Ignore;
      switch (e) {
        case b.requestAction.Add:
          P = L(H);
          break;
        case b.requestAction.Delete:
          P = N(H);
          break;
      }
      a.push(h(H, P, O, D)), y++;
    }
    return a;
  }, G();
};
b.where = { Row: 0, Column: 1 };
b.requestAction = { Add: 0, Delete: 1 };
b.resultAction = { Ignore: 0, SubtractSpanCount: 1, RemoveCell: 2, AddCell: 3, SumSpanCount: 4 };
class Uo {
  /**
   * handle tab key
   *
   * @param {WrappedRange} rng
   * @param {Boolean} isShift
   */
  tab(t, e) {
    const o = r.ancestor(t.commonAncestor(), r.isCell), n = r.ancestor(o, r.isTable), s = r.listDescendant(n, r.isCell), a = f[e ? "prev" : "next"](s, o);
    a && w.create(a, 0).select();
  }
  /**
   * Add a new row
   *
   * @param {WrappedRange} rng
   * @param {String} position (top/bottom)
   * @return {Node}
   */
  addRow(t, e) {
    const o = r.ancestor(t.commonAncestor(), r.isCell), n = l(o).closest("tr"), s = this.recoverAttributes(n), a = l("<tr" + s + "></tr>"), d = new b(
      o,
      b.where.Row,
      b.requestAction.Add,
      l(n).closest("table")[0]
    ).getActionList();
    for (let h = 0; h < d.length; h++) {
      const u = d[h], p = this.recoverAttributes(u.baseCell);
      switch (u.action) {
        case b.resultAction.AddCell:
          a.append("<td" + p + ">" + r.blank + "</td>");
          break;
        case b.resultAction.SumSpanCount:
          {
            if (e === "top" && (u.baseCell.parent ? u.baseCell.closest("tr").rowIndex : 0) <= n[0].rowIndex) {
              const L = l("<div></div>").append(l("<td" + p + ">" + r.blank + "</td>").removeAttr("rowspan")).html();
              a.append(L);
              break;
            }
            let k = parseInt(u.baseCell.rowSpan, 10);
            k++, u.baseCell.setAttribute("rowSpan", k);
          }
          break;
      }
    }
    if (e === "top")
      n.before(a);
    else {
      if (o.rowSpan > 1) {
        const u = n[0].rowIndex + (o.rowSpan - 2);
        l(l(n).parent().find("tr")[u]).after(l(a));
        return;
      }
      n.after(a);
    }
  }
  /**
   * Add a new col
   *
   * @param {WrappedRange} rng
   * @param {String} position (left/right)
   * @return {Node}
   */
  addCol(t, e) {
    const o = r.ancestor(t.commonAncestor(), r.isCell), n = l(o).closest("tr");
    l(n).siblings().push(n);
    const c = new b(
      o,
      b.where.Column,
      b.requestAction.Add,
      l(n).closest("table")[0]
    ).getActionList();
    for (let d = 0; d < c.length; d++) {
      const h = c[d], u = this.recoverAttributes(h.baseCell);
      switch (h.action) {
        case b.resultAction.AddCell:
          e === "right" ? l(h.baseCell).after("<td" + u + ">" + r.blank + "</td>") : l(h.baseCell).before("<td" + u + ">" + r.blank + "</td>");
          break;
        case b.resultAction.SumSpanCount:
          if (e === "right") {
            let p = parseInt(h.baseCell.colSpan, 10);
            p++, h.baseCell.setAttribute("colSpan", p);
          } else
            l(h.baseCell).before("<td" + u + ">" + r.blank + "</td>");
          break;
      }
    }
  }
  /*
  * Copy attributes from element.
  *
  * @param {object} Element to recover attributes.
  * @return {string} Copied string elements.
  */
  recoverAttributes(t) {
    let e = "";
    if (!t)
      return e;
    const o = t.attributes || [];
    for (let n = 0; n < o.length; n++)
      o[n].name.toLowerCase() !== "id" && o[n].specified && (e += " " + o[n].name + "='" + o[n].value + "'");
    return e;
  }
  /**
   * Delete current row
   *
   * @param {WrappedRange} rng
   * @return {Node}
   */
  deleteRow(t) {
    const e = r.ancestor(t.commonAncestor(), r.isCell), o = l(e).closest("tr"), n = o.children("td, th").index(l(e)), s = o[0].rowIndex, c = new b(
      e,
      b.where.Row,
      b.requestAction.Delete,
      l(o).closest("table")[0]
    ).getActionList();
    for (let d = 0; d < c.length; d++) {
      if (!c[d])
        continue;
      const h = c[d].baseCell, u = c[d].virtualTable, p = h.rowSpan && h.rowSpan > 1;
      let k = p ? parseInt(h.rowSpan, 10) : 0;
      switch (c[d].action) {
        case b.resultAction.Ignore:
          continue;
        case b.resultAction.AddCell:
          {
            const C = o.next("tr")[0];
            if (!C)
              continue;
            const N = o[0].cells[n];
            p && (k > 2 ? (k--, C.insertBefore(N, C.cells[n]), C.cells[n].setAttribute("rowSpan", k), C.cells[n].innerHTML = "") : k === 2 && (C.insertBefore(N, C.cells[n]), C.cells[n].removeAttribute("rowSpan"), C.cells[n].innerHTML = ""));
          }
          continue;
        case b.resultAction.SubtractSpanCount:
          p && (k > 2 ? (k--, h.setAttribute("rowSpan", k), u.rowIndex !== s && h.cellIndex === n && (h.innerHTML = "")) : k === 2 && (h.removeAttribute("rowSpan"), u.rowIndex !== s && h.cellIndex === n && (h.innerHTML = "")));
          continue;
        case b.resultAction.RemoveCell:
          continue;
      }
    }
    o.remove();
  }
  /**
   * Delete current col
   *
   * @param {WrappedRange} rng
   * @return {Node}
   */
  deleteCol(t) {
    const e = r.ancestor(t.commonAncestor(), r.isCell), o = l(e).closest("tr"), n = o.children("td, th").index(l(e)), a = new b(
      e,
      b.where.Column,
      b.requestAction.Delete,
      l(o).closest("table")[0]
    ).getActionList();
    for (let c = 0; c < a.length; c++)
      if (a[c])
        switch (a[c].action) {
          case b.resultAction.Ignore:
            continue;
          case b.resultAction.SubtractSpanCount:
            {
              const d = a[c].baseCell;
              if (d.colSpan && d.colSpan > 1) {
                let u = d.colSpan ? parseInt(d.colSpan, 10) : 0;
                u > 2 ? (u--, d.setAttribute("colSpan", u), d.cellIndex === n && (d.innerHTML = "")) : u === 2 && (d.removeAttribute("colSpan"), d.cellIndex === n && (d.innerHTML = ""));
              }
            }
            continue;
          case b.resultAction.RemoveCell:
            r.remove(a[c].baseCell, !0);
            continue;
        }
  }
  /**
   * create empty table element
   *
   * @param {Number} rowCount
   * @param {Number} colCount
   * @return {Node}
   */
  createTable(t, e, o) {
    const n = [];
    let s;
    for (let h = 0; h < t; h++)
      n.push("<td>" + r.blank + "</td>");
    s = n.join("");
    const a = [];
    let c;
    for (let h = 0; h < e; h++)
      a.push("<tr>" + s + "</tr>");
    c = a.join("");
    const d = l("<table>" + c + "</table>");
    return o && o.tableClassName && d.addClass(o.tableClassName), d[0];
  }
  /**
   * Delete current table
   *
   * @param {WrappedRange} rng
   * @return {Node}
   */
  deleteTable(t) {
    const e = r.ancestor(t.commonAncestor(), r.isCell);
    l(e).closest("table").remove();
  }
}
const jo = "bogus", Wo = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/, Ko = /^(\+?\d{1,3}[\s-]?)?(\d{1,4})[\s-]?(\d{1,4})[\s-]?(\d{1,4})$/, Vo = /^([A-Za-z][A-Za-z0-9+-.]*\:|#|\/)/;
class _o {
  constructor(t) {
    this.context = t, this.$note = t.layoutInfo.note, this.$editor = t.layoutInfo.editor, this.$editable = t.layoutInfo.editable, this.options = t.options, this.lang = this.options.langInfo, this.editable = this.$editable[0], this.lastRange = null, this.snapshot = null, this.style = new zo(), this.table = new Uo(), this.typing = new Oo(t), this.bullet = new ue(), this.history = new Bo(t), this.context.memo("help.escape", this.lang.help.escape), this.context.memo("help.undo", this.lang.help.undo), this.context.memo("help.redo", this.lang.help.redo), this.context.memo("help.tab", this.lang.help.tab), this.context.memo("help.untab", this.lang.help.untab), this.context.memo("help.insertParagraph", this.lang.help.insertParagraph), this.context.memo("help.insertOrderedList", this.lang.help.insertOrderedList), this.context.memo("help.insertUnorderedList", this.lang.help.insertUnorderedList), this.context.memo("help.indent", this.lang.help.indent), this.context.memo("help.outdent", this.lang.help.outdent), this.context.memo("help.formatPara", this.lang.help.formatPara), this.context.memo("help.insertHorizontalRule", this.lang.help.insertHorizontalRule), this.context.memo("help.fontName", this.lang.help.fontName);
    const e = [
      "bold",
      "italic",
      "underline",
      "strikethrough",
      "superscript",
      "subscript",
      "justifyLeft",
      "justifyCenter",
      "justifyRight",
      "justifyFull",
      "formatBlock",
      "removeFormat",
      "backColor"
    ];
    for (let o = 0, n = e.length; o < n; o++)
      this[e[o]] = /* @__PURE__ */ ((s) => (a) => {
        this.beforeCommand(), document.execCommand(s, !1, a), this.afterCommand(!0);
      })(e[o]), this.context.memo("help." + e[o], this.lang.help[e[o]]);
    this.fontName = this.wrapCommand((o) => this.fontStyling("font-family", $.validFontName(o))), this.fontSize = this.wrapCommand((o) => {
      const n = this.currentStyle()["font-size-unit"];
      return this.fontStyling("font-size", o + n);
    }), this.fontSizeUnit = this.wrapCommand((o) => {
      const n = this.currentStyle()["font-size"];
      return this.fontStyling("font-size", n + o);
    });
    for (let o = 1; o <= 6; o++)
      this["formatH" + o] = /* @__PURE__ */ ((n) => () => {
        this.formatBlock("H" + n);
      })(o), this.context.memo("help.formatH" + o, this.lang.help["formatH" + o]);
    this.insertParagraph = this.wrapCommand(() => {
      this.typing.insertParagraph(this.editable);
    }), this.insertOrderedList = this.wrapCommand(() => {
      this.bullet.insertOrderedList(this.editable);
    }), this.insertUnorderedList = this.wrapCommand(() => {
      this.bullet.insertUnorderedList(this.editable);
    }), this.indent = this.wrapCommand(() => {
      this.bullet.indent(this.editable);
    }), this.outdent = this.wrapCommand(() => {
      this.bullet.outdent(this.editable);
    }), this.insertNode = this.wrapCommand((o) => {
      if (this.isLimited(l(o).text().length))
        return;
      this.getLastRange().insertNode(o), this.setLastRange(w.createFromNodeAfter(o).select());
    }), this.insertText = this.wrapCommand((o) => {
      if (this.isLimited(o.length))
        return;
      const s = this.getLastRange().insertNode(r.createText(o));
      this.setLastRange(w.create(s, r.nodeLength(s)).select());
    }), this.pasteHTML = this.wrapCommand((o) => {
      if (this.isLimited(o.length))
        return;
      o = this.context.invoke("codeview.purify", o);
      const n = this.getLastRange().pasteHTML(o);
      this.setLastRange(w.createFromNodeAfter(f.last(n)).select());
    }), this.formatBlock = this.wrapCommand((o, n) => {
      const s = this.options.callbacks.onApplyCustomStyle;
      s ? s.call(this, n, this.context, this.onFormatBlock) : this.onFormatBlock(o, n);
    }), this.insertHorizontalRule = this.wrapCommand(() => {
      const o = this.getLastRange().insertNode(r.create("HR"));
      o.nextSibling && this.setLastRange(w.create(o.nextSibling, 0).normalize().select());
    }), this.lineHeight = this.wrapCommand((o) => {
      this.style.stylePara(this.getLastRange(), {
        lineHeight: o
      });
    }), this.createLink = this.wrapCommand((o) => {
      let n = [], s = o.url;
      const a = o.text, c = o.isNewWindow, d = this.options.linkAddNoReferrer, h = this.options.linkAddNoOpener;
      let u = o.range || this.getLastRange();
      const p = a.length - u.toString().length;
      if (p > 0 && this.isLimited(p))
        return;
      const k = u.toString() !== a;
      typeof s == "string" && (s = s.trim()), this.options.onCreateLink ? s = this.options.onCreateLink(s) : s = this.checkLinkUrl(s);
      let C = [];
      if (k) {
        u = u.deleteContents();
        const N = u.insertNode(l("<A></A>").text(a)[0]);
        C.push(N);
      } else
        C = this.style.styleNodes(u, {
          nodeName: "A",
          expandClosestSibling: !0,
          onlyPartialContains: !0
        });
      l.each(C, (N, L) => {
        l(L).attr("href", s), c ? (l(L).attr("target", "_blank"), d && n.push("noreferrer"), h && n.push("noopener"), n.length && l(L).attr("rel", n.join(" "))) : l(L).removeAttr("target");
      }), this.setLastRange(
        this.createRangeFromList(C).select()
      );
    }), this.color = this.wrapCommand((o) => {
      const n = o.foreColor, s = o.backColor;
      n && document.execCommand("foreColor", !1, n), s && document.execCommand("backColor", !1, s);
    }), this.foreColor = this.wrapCommand((o) => {
      document.execCommand("foreColor", !1, o);
    }), this.insertTable = this.wrapCommand((o) => {
      const n = o.split("x");
      this.getLastRange().deleteContents().insertNode(this.table.createTable(n[0], n[1], this.options));
    }), this.removeMedia = this.wrapCommand(() => {
      let o = l(this.restoreTarget()).parent();
      o.closest("figure").length ? o.closest("figure").remove() : o = l(this.restoreTarget()).detach(), this.setLastRange(w.createFromSelection(o).select()), this.context.triggerEvent("media.delete", o, this.$editable);
    }), this.floatMe = this.wrapCommand((o) => {
      const n = l(this.restoreTarget());
      n.toggleClass("note-float-left", o === "left"), n.toggleClass("note-float-right", o === "right"), n.css("float", o === "none" ? "" : o);
    }), this.resize = this.wrapCommand((o) => {
      const n = l(this.restoreTarget());
      o = parseFloat(o), o === 0 ? n.css("width", "") : n.css({
        width: o * 100 + "%",
        height: ""
      });
    });
  }
  initialize() {
    this.$editable.on("keydown", (t) => {
      if (t.keyCode === x.code.ENTER && this.context.triggerEvent("enter", t), this.context.triggerEvent("keydown", t), this.snapshot = this.history.makeSnapshot(), this.hasKeyShortCut = !1, t.isDefaultPrevented() || (this.options.shortcuts ? this.hasKeyShortCut = this.handleKeyMap(t) : this.preventDefaultEditableShortCuts(t)), this.isLimited(1, t)) {
        const e = this.getLastRange();
        if (e.eo - e.so === 0)
          return !1;
      }
      this.setLastRange(), this.options.recordEveryKeystroke && this.hasKeyShortCut === !1 && this.history.recordUndo();
    }).on("keyup", (t) => {
      this.setLastRange(), this.context.triggerEvent("keyup", t);
    }).on("focus", (t) => {
      this.setLastRange(), this.context.triggerEvent("focus", t);
    }).on("blur", (t) => {
      this.context.triggerEvent("blur", t);
    }).on("mousedown", (t) => {
      this.context.triggerEvent("mousedown", t);
    }).on("mouseup", (t) => {
      this.setLastRange(), this.history.recordUndo(), this.context.triggerEvent("mouseup", t);
    }).on("scroll", (t) => {
      this.context.triggerEvent("scroll", t);
    }).on("paste", (t) => {
      this.setLastRange(), this.context.triggerEvent("paste", t);
    }).on("copy", (t) => {
      this.context.triggerEvent("copy", t);
    }).on("input", () => {
      this.isLimited(0) && this.snapshot && this.history.applySnapshot(this.snapshot);
    }), this.$editable.attr("spellcheck", this.options.spellCheck), this.$editable.attr("autocorrect", this.options.spellCheck), this.options.disableGrammar && this.$editable.attr("data-gramm", !1), this.$editable.html(r.html(this.$note) || r.emptyPara), this.$editable.on($.inputEventName, v.debounce(() => {
      this.context.triggerEvent("change", this.$editable.html(), this.$editable);
    }, 10)), this.$editable.on("focusin", (t) => {
      this.context.triggerEvent("focusin", t);
    }).on("focusout", (t) => {
      this.context.triggerEvent("focusout", t);
    }), this.options.airMode ? this.options.overrideContextMenu && this.$editor.on("contextmenu", (t) => (this.context.triggerEvent("contextmenu", t), !1)) : (this.options.width && this.$editor.outerWidth(this.options.width), this.options.height && this.$editable.outerHeight(this.options.height), this.options.maxHeight && this.$editable.css("max-height", this.options.maxHeight), this.options.minHeight && this.$editable.css("min-height", this.options.minHeight)), this.history.recordUndo(), this.setLastRange();
  }
  destroy() {
    this.$editable.off();
  }
  handleKeyMap(t) {
    const e = this.options.keyMap[$.isMac ? "mac" : "pc"], o = [];
    t.metaKey && o.push("CMD"), t.ctrlKey && !t.altKey && o.push("CTRL"), t.shiftKey && o.push("SHIFT");
    const n = x.nameFromCode[t.keyCode];
    n && o.push(n);
    const s = e[o.join("+")];
    if (n === "TAB" && !this.options.tabDisable)
      this.afterCommand();
    else if (s) {
      if (this.context.invoke(s) !== !1)
        return t.preventDefault(), !0;
    } else x.isEdit(t.keyCode) && (x.isRemove(t.keyCode) && this.context.invoke("removed"), this.afterCommand());
    return !1;
  }
  preventDefaultEditableShortCuts(t) {
    (t.ctrlKey || t.metaKey) && f.contains([66, 73, 85], t.keyCode) && t.preventDefault();
  }
  isLimited(t, e) {
    return t = t || 0, typeof e < "u" && (x.isMove(e.keyCode) || x.isNavigation(e.keyCode) || e.ctrlKey || e.metaKey || f.contains([x.code.BACKSPACE, x.code.DELETE], e.keyCode)) ? !1 : this.options.maxTextLength > 0 && this.$editable.text().length + t > this.options.maxTextLength;
  }
  checkLinkUrl(t) {
    return Wo.test(t) ? "mailto:" + t : Ko.test(t) ? "tel:" + t : Vo.test(t) ? t : "http://" + t;
  }
  /**
   * create range
   * @return {WrappedRange}
   */
  createRange() {
    return this.focus(), this.setLastRange(), this.getLastRange();
  }
  /**
   * create a new range from the list of elements
   *
   * @param {list} dom element list
   * @return {WrappedRange}
   */
  createRangeFromList(t) {
    const o = w.createFromNodeBefore(f.head(t)).getStartPoint(), s = w.createFromNodeAfter(f.last(t)).getEndPoint();
    return w.create(
      o.node,
      o.offset,
      s.node,
      s.offset
    );
  }
  /**
   * set the last range
   *
   * if given rng is exist, set rng as the last range
   * or create a new range at the end of the document
   *
   * @param {WrappedRange} rng
   */
  setLastRange(t) {
    t ? this.lastRange = t : (this.lastRange = w.create(this.editable), l(this.lastRange.sc).closest(".note-editable").length === 0 && (this.lastRange = w.createFromBodyElement(this.editable)));
  }
  /**
   * get the last range
   *
   * if there is a saved last range, return it
   * or create a new range and return it
   *
   * @return {WrappedRange}
   */
  getLastRange() {
    return this.lastRange || this.setLastRange(), this.lastRange;
  }
  /**
   * saveRange
   *
   * save current range
   *
   * @param {Boolean} [thenCollapse=false]
   */
  saveRange(t) {
    t && this.getLastRange().collapse().select();
  }
  /**
   * restoreRange
   *
   * restore lately range
   */
  restoreRange() {
    this.lastRange && (this.lastRange.select(), this.focus());
  }
  saveTarget(t) {
    this.$editable.data("target", t);
  }
  clearTarget() {
    this.$editable.removeData("target");
  }
  restoreTarget() {
    return this.$editable.data("target");
  }
  /**
   * currentStyle
   *
   * current style
   * @return {Object|Boolean} unfocus
   */
  currentStyle() {
    let t = w.create();
    return t && (t = t.normalize()), t ? this.style.current(t) : this.style.fromNode(this.$editable);
  }
  /**
   * style from node
   *
   * @param {jQuery} $node
   * @return {Object}
   */
  styleFromNode(t) {
    return this.style.fromNode(t);
  }
  /**
   * undo
   */
  undo() {
    this.context.triggerEvent("before.command", this.$editable.html()), this.history.undo(), this.context.triggerEvent("change", this.$editable.html(), this.$editable);
  }
  /*
  * commit
  */
  commit() {
    this.context.triggerEvent("before.command", this.$editable.html()), this.history.commit(), this.context.triggerEvent("change", this.$editable.html(), this.$editable);
  }
  /**
   * redo
   */
  redo() {
    this.context.triggerEvent("before.command", this.$editable.html()), this.history.redo(), this.context.triggerEvent("change", this.$editable.html(), this.$editable);
  }
  /**
   * before command
   */
  beforeCommand() {
    this.context.triggerEvent("before.command", this.$editable.html()), document.execCommand("styleWithCSS", !1, this.options.styleWithCSS), this.focus();
  }
  /**
   * after command
   * @param {Boolean} isPreventTrigger
   */
  afterCommand(t) {
    this.normalizeContent(), this.history.recordUndo(), t || this.context.triggerEvent("change", this.$editable.html(), this.$editable);
  }
  /**
   * handle tab key
   */
  tab() {
    const t = this.getLastRange();
    if (t.isCollapsed() && t.isOnCell())
      this.table.tab(t);
    else {
      if (this.options.tabSize === 0)
        return !1;
      this.isLimited(this.options.tabSize) || (this.beforeCommand(), this.typing.insertTab(t, this.options.tabSize), this.afterCommand());
    }
  }
  /**
   * handle shift+tab key
   */
  untab() {
    const t = this.getLastRange();
    if (t.isCollapsed() && t.isOnCell())
      this.table.tab(t, !0);
    else if (this.options.tabSize === 0)
      return !1;
  }
  /**
   * run given function between beforeCommand and afterCommand
   */
  wrapCommand(t) {
    return function() {
      this.beforeCommand(), t.apply(this, arguments), this.afterCommand();
    };
  }
  /**
   * removed (function added by 1der1)
  */
  removed(t, e, o) {
    t = w.create(), t.isCollapsed() && t.isOnCell() && (e = t.ec, (o = e.tagName) && e.childElementCount === 1 && e.childNodes[0].tagName === "BR" && (o === "P" ? e.remove() : ["TH", "TD"].indexOf(o) >= 0 && e.firstChild.remove()));
  }
  /**
   * insert image
   *
   * @param {String} src
   * @param {String|Function} param
   * @return {Promise}
   */
  insertImage(t, e) {
    return Mo(t).then((o) => {
      this.beforeCommand(), typeof e == "function" ? e(o) : (typeof e == "string" && o.attr("data-filename", e), o.css("width", Math.min(this.$editable.width(), o.width()))), o.show(), this.getLastRange().insertNode(o[0]), this.setLastRange(w.createFromNodeAfter(o[0]).select()), this.afterCommand();
    }).fail((o) => {
      this.context.triggerEvent("image.upload.error", o);
    });
  }
  /**
   * insertImages
   * @param {File[]} files
   */
  insertImagesAsDataURL(t) {
    l.each(t, (e, o) => {
      const n = o.name;
      this.options.maximumImageFileSize && this.options.maximumImageFileSize < o.size ? this.context.triggerEvent("image.upload.error", this.lang.image.maximumFileSizeError) : Ho(o).then((s) => this.insertImage(s, n)).fail(() => {
        this.context.triggerEvent("image.upload.error");
      });
    });
  }
  /**
   * insertImagesOrCallback
   * @param {File[]} files
   */
  insertImagesOrCallback(t) {
    this.options.callbacks.onImageUpload ? this.context.triggerEvent("image.upload", t) : this.insertImagesAsDataURL(t);
  }
  /**
   * return selected plain text
   * @return {String} text
   */
  getSelectedText() {
    let t = this.getLastRange();
    return t.isOnAnchor() && (t = w.createFromNode(r.ancestor(t.sc, r.isAnchor))), t.toString();
  }
  onFormatBlock(t, e) {
    if (document.execCommand("FormatBlock", !1, $.isMSIE ? "<" + t + ">" : t), e && e.length && (e[0].tagName.toUpperCase() !== t.toUpperCase() && (e = e.find(t)), e && e.length)) {
      const o = this.createRange(), n = l([o.sc, o.ec]).closest(t);
      n.removeClass();
      const s = e[0].className || "";
      s && n.addClass(s);
    }
  }
  formatPara() {
    this.formatBlock("P");
  }
  fontStyling(t, e) {
    const o = this.getLastRange();
    if (o !== "") {
      const n = this.style.styleNodes(o);
      if (this.$editor.find(".note-status-output").html(""), l(n).css(t, e), o.isCollapsed()) {
        const s = f.head(n);
        s && !r.nodeLength(s) && (s.innerHTML = r.ZERO_WIDTH_NBSP_CHAR, w.createFromNode(s.firstChild).select(), this.setLastRange(), this.$editable.data(jo, s));
      } else
        o.select();
    } else {
      const n = l.now();
      this.$editor.find(".note-status-output").html('<div id="note-status-output-' + n + '" class="alert alert-info">' + this.lang.output.noSelection + "</div>"), setTimeout(function() {
        l("#note-status-output-" + n).remove();
      }, 5e3);
    }
  }
  /**
   * unlink
   *
   * @type command
   */
  unlink() {
    let t = this.getLastRange();
    if (t.isOnAnchor()) {
      const e = r.ancestor(t.sc, r.isAnchor);
      t = w.createFromNode(e), t.select(), this.setLastRange(), this.beforeCommand(), document.execCommand("unlink"), this.afterCommand();
    }
  }
  /**
   * returns link info
   *
   * @return {Object}
   * @return {WrappedRange} return.range
   * @return {String} return.text
   * @return {Boolean} [return.isNewWindow=true]
   * @return {String} [return.url=""]
   */
  getLinkInfo() {
    this.hasFocus() || this.focus();
    const t = this.getLastRange().expand(r.isAnchor), e = l(f.head(t.nodes(r.isAnchor))), o = {
      range: t,
      text: t.toString(),
      url: e.length ? e.attr("href") : ""
    };
    return e.length && (o.isNewWindow = e.attr("target") === "_blank"), o;
  }
  addRow(t) {
    const e = this.getLastRange(this.$editable);
    e.isCollapsed() && e.isOnCell() && (this.beforeCommand(), this.table.addRow(e, t), this.afterCommand());
  }
  addCol(t) {
    const e = this.getLastRange(this.$editable);
    e.isCollapsed() && e.isOnCell() && (this.beforeCommand(), this.table.addCol(e, t), this.afterCommand());
  }
  deleteRow() {
    const t = this.getLastRange(this.$editable);
    t.isCollapsed() && t.isOnCell() && (this.beforeCommand(), this.table.deleteRow(t), this.afterCommand());
  }
  deleteCol() {
    const t = this.getLastRange(this.$editable);
    t.isCollapsed() && t.isOnCell() && (this.beforeCommand(), this.table.deleteCol(t), this.afterCommand());
  }
  deleteTable() {
    const t = this.getLastRange(this.$editable);
    t.isCollapsed() && t.isOnCell() && (this.beforeCommand(), this.table.deleteTable(t), this.afterCommand());
  }
  /**
   * @param {Position} pos
   * @param {jQuery} $target - target element
   * @param {Boolean} [bKeepRatio] - keep ratio
   */
  resizeTo(t, e, o) {
    let n;
    if (o) {
      const s = t.y / t.x, a = e.data("ratio");
      n = {
        width: a > s ? t.x : t.y / a,
        height: a > s ? t.x * a : t.y
      };
    } else
      n = {
        width: t.x,
        height: t.y
      };
    e.css(n);
  }
  /**
   * returns whether editable area has focus or not.
   */
  hasFocus() {
    return this.$editable.is(":focus");
  }
  /**
   * set focus
   */
  focus() {
    this.hasFocus() || this.$editable.trigger("focus");
  }
  /**
   * returns whether contents is empty or not.
   * @return {Boolean}
   */
  isEmpty() {
    return r.isEmpty(this.$editable[0]) || r.emptyPara === this.$editable.html();
  }
  /**
   * Removes all contents and restores the editable instance to an _emptyPara_.
   */
  empty() {
    this.context.invoke("code", r.emptyPara);
  }
  /**
   * normalize content
   */
  normalizeContent() {
    this.$editable[0].normalize();
  }
}
class qo {
  constructor(t) {
    this.context = t, this.options = t.options, this.$editable = t.layoutInfo.editable;
  }
  initialize() {
    this.$editable.on("paste", this.pasteByEvent.bind(this));
  }
  /**
   * paste by clipboard event
   *
   * @param {Event} event
   */
  pasteByEvent(t) {
    if (this.context.isDisabled())
      return;
    const e = t.originalEvent.clipboardData;
    if (e && e.items && e.items.length) {
      const o = e.files, n = e.getData("Text");
      o.length > 0 && this.options.allowClipboardImagePasting && (this.context.invoke("editor.insertImagesOrCallback", o), t.preventDefault()), n.length > 0 && this.context.invoke("editor.isLimited", n.length) && t.preventDefault();
    } else if (window.clipboardData) {
      let o = window.clipboardData.getData("text");
      this.context.invoke("editor.isLimited", o.length) && t.preventDefault();
    }
    setTimeout(() => {
      this.context.invoke("editor.afterCommand");
    }, 10);
  }
}
class Go {
  constructor(t) {
    this.context = t, this.$eventListener = l(document), this.$editor = t.layoutInfo.editor, this.$editable = t.layoutInfo.editable, this.options = t.options, this.lang = this.options.langInfo, this.documentEventHandlers = {}, this.$dropzone = l([
      '<div class="note-dropzone">',
      '<div class="note-dropzone-message"></div>',
      "</div>"
    ].join("")).prependTo(this.$editor);
  }
  /**
   * attach Drag and Drop Events
   */
  initialize() {
    this.options.disableDragAndDrop ? (this.documentEventHandlers.onDrop = (t) => {
      t.preventDefault();
    }, this.$eventListener = this.$dropzone, this.$eventListener.on("drop", this.documentEventHandlers.onDrop)) : this.attachDragAndDropEvent();
  }
  /**
   * attach Drag and Drop Events
   */
  attachDragAndDropEvent() {
    let t = l();
    const e = this.$dropzone.find(".note-dropzone-message");
    this.documentEventHandlers.onDragenter = (o) => {
      const n = this.context.invoke("codeview.isActivated"), s = this.$editor.width() > 0 && this.$editor.height() > 0;
      !n && !t.length && s && (this.$editor.addClass("dragover"), this.$dropzone.width(this.$editor.width()), this.$dropzone.height(this.$editor.height()), e.text(this.lang.image.dragImageHere)), t = t.add(o.target);
    }, this.documentEventHandlers.onDragleave = (o) => {
      t = t.not(o.target), (!t.length || o.target.nodeName === "BODY") && (t = l(), this.$editor.removeClass("dragover"));
    }, this.documentEventHandlers.onDrop = () => {
      t = l(), this.$editor.removeClass("dragover");
    }, this.$eventListener.on("dragenter", this.documentEventHandlers.onDragenter).on("dragleave", this.documentEventHandlers.onDragleave).on("drop", this.documentEventHandlers.onDrop), this.$dropzone.on("dragenter", () => {
      this.$dropzone.addClass("hover"), e.text(this.lang.image.dropImage);
    }).on("dragleave", () => {
      this.$dropzone.removeClass("hover"), e.text(this.lang.image.dragImageHere);
    }), this.$dropzone.on("drop", (o) => {
      const n = o.originalEvent.dataTransfer;
      o.preventDefault(), n && n.files && n.files.length ? (this.$editable.trigger("focus"), this.context.invoke("editor.insertImagesOrCallback", n.files)) : l.each(n.types, (s, a) => {
        if (a.toLowerCase().indexOf("_moz_") > -1)
          return;
        const c = n.getData(a);
        a.toLowerCase().indexOf("text") > -1 ? this.context.invoke("editor.pasteHTML", c) : l(c).each((d, h) => {
          this.context.invoke("editor.insertNode", h);
        });
      });
    }).on("dragover", !1);
  }
  destroy() {
    Object.keys(this.documentEventHandlers).forEach((t) => {
      this.$eventListener.off(t.slice(2).toLowerCase(), this.documentEventHandlers[t]);
    }), this.documentEventHandlers = {};
  }
}
class Yo {
  constructor(t) {
    this.context = t, this.$editor = t.layoutInfo.editor, this.$editable = t.layoutInfo.editable, this.$codable = t.layoutInfo.codable, this.options = t.options, this.CodeMirrorConstructor = window.CodeMirror, this.options.codemirror.CodeMirrorConstructor && (this.CodeMirrorConstructor = this.options.codemirror.CodeMirrorConstructor);
  }
  sync(t) {
    const e = this.isActivated(), o = this.CodeMirrorConstructor;
    e && (t ? o ? this.$codable.data("cmEditor").getDoc().setValue(t) : this.$codable.val(t) : o && this.$codable.data("cmEditor").save());
  }
  initialize() {
    this.$codable.on("keyup", (t) => {
      t.keyCode === x.code.ESCAPE && this.deactivate();
    });
  }
  /**
   * @return {Boolean}
   */
  isActivated() {
    return this.$editor.hasClass("codeview");
  }
  /**
   * toggle codeview
   */
  toggle() {
    this.isActivated() ? this.deactivate() : this.activate(), this.context.triggerEvent("codeview.toggled");
  }
  /**
   * purify input value
   * @param value
   * @returns {*}
   */
  purify(t) {
    if (this.options.codeviewFilter && (t = t.replace(this.options.codeviewFilterRegex, ""), this.options.codeviewIframeFilter)) {
      const e = this.options.codeviewIframeWhitelistSrc.concat(this.options.codeviewIframeWhitelistSrcBase);
      t = t.replace(/(<iframe.*?>.*?(?:<\/iframe>)?)/gi, function(o) {
        if (/<.+src(?==?('|"|\s)?)[\s\S]+src(?=('|"|\s)?)[^>]*?>/i.test(o))
          return "";
        for (const n of e)
          if (new RegExp('src="(https?:)?//' + n.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&") + '/(.+)"').test(o))
            return o;
        return "";
      });
    }
    return t;
  }
  /**
   * activate code view
   */
  activate() {
    const t = this.CodeMirrorConstructor;
    if (this.$codable.val(r.html(this.$editable, this.options.prettifyHtml)), this.$codable.height(this.$editable.height()), this.context.invoke("toolbar.updateCodeview", !0), this.context.invoke("airPopover.updateCodeview", !0), this.$editor.addClass("codeview"), this.$codable.trigger("focus"), t) {
      const e = t.fromTextArea(this.$codable[0], this.options.codemirror);
      if (this.options.codemirror.tern) {
        const o = new t.TernServer(this.options.codemirror.tern);
        e.ternServer = o, e.on("cursorActivity", (n) => {
          o.updateArgHints(n);
        });
      }
      e.on("blur", (o) => {
        this.context.triggerEvent("blur.codeview", e.getValue(), o);
      }), e.on("change", () => {
        this.context.triggerEvent("change.codeview", e.getValue(), e);
      }), e.setSize(null, this.$editable.outerHeight()), this.$codable.data("cmEditor", e);
    } else
      this.$codable.on("blur", (e) => {
        this.context.triggerEvent("blur.codeview", this.$codable.val(), e);
      }), this.$codable.on("input", () => {
        this.context.triggerEvent("change.codeview", this.$codable.val(), this.$codable);
      });
  }
  /**
   * deactivate code view
   */
  deactivate() {
    if (this.CodeMirrorConstructor) {
      const n = this.$codable.data("cmEditor");
      this.$codable.val(n.getValue()), n.toTextArea();
    }
    const e = this.purify(r.value(this.$codable, this.options.prettifyHtml) || r.emptyPara), o = this.$editable.html() !== e;
    this.$editable.html(e), this.$editable.height(this.options.height ? this.$codable.height() : "auto"), this.$editor.removeClass("codeview"), o && this.context.triggerEvent("change", this.$editable.html(), this.$editable), this.$editable.trigger("focus"), this.context.invoke("toolbar.updateCodeview", !1), this.context.invoke("airPopover.updateCodeview", !1);
  }
  destroy() {
    this.isActivated() && this.deactivate();
  }
}
const jt = 24;
class Zo {
  constructor(t) {
    this.$document = l(document), this.$statusbar = t.layoutInfo.statusbar, this.$editable = t.layoutInfo.editable, this.$codable = t.layoutInfo.codable, this.options = t.options;
  }
  initialize() {
    if (this.options.airMode || this.options.disableResizeEditor) {
      this.destroy();
      return;
    }
    this.$statusbar.on("mousedown touchstart", (t) => {
      t.preventDefault(), t.stopPropagation();
      const e = this.$editable.offset().top - this.$document.scrollTop(), o = this.$codable.offset().top - this.$document.scrollTop(), n = (s) => {
        let a = s.type == "mousemove" ? s : s.originalEvent.touches[0], c = a.clientY - (e + jt), d = a.clientY - (o + jt);
        c = this.options.minheight > 0 ? Math.max(c, this.options.minheight) : c, c = this.options.maxHeight > 0 ? Math.min(c, this.options.maxHeight) : c, d = this.options.minheight > 0 ? Math.max(d, this.options.minheight) : d, d = this.options.maxHeight > 0 ? Math.min(d, this.options.maxHeight) : d, this.$editable.height(c), this.$codable.height(d);
      };
      this.$document.on("mousemove touchmove", n).one("mouseup touchend", () => {
        this.$document.off("mousemove touchmove", n);
      });
    });
  }
  destroy() {
    this.$statusbar.off(), this.$statusbar.addClass("locked");
  }
}
class Xo {
  constructor(t) {
    this.context = t, this.$editor = t.layoutInfo.editor, this.$toolbar = t.layoutInfo.toolbar, this.$editable = t.layoutInfo.editable, this.$codable = t.layoutInfo.codable, this.$window = l(window), this.$scrollbar = l("html, body"), this.scrollbarClassName = "note-fullscreen-body", this.onResize = () => {
      this.resizeTo({
        h: this.$window.height() - this.$toolbar.outerHeight()
      });
    };
  }
  resizeTo(t) {
    this.$editable.css("height", t.h), this.$codable.css("height", t.h), this.$codable.data("cmeditor") && this.$codable.data("cmeditor").setsize(null, t.h);
  }
  /**
   * toggle fullscreen
   */
  toggle() {
    this.$editor.toggleClass("fullscreen");
    const t = this.isFullscreen();
    this.$scrollbar.toggleClass(this.scrollbarClassName, t), t ? (this.$editable.data("orgHeight", this.$editable.css("height")), this.$editable.data("orgMaxHeight", this.$editable.css("maxHeight")), this.$editable.css("maxHeight", ""), this.$window.on("resize", this.onResize).trigger("resize")) : (this.$window.off("resize", this.onResize), this.resizeTo({ h: this.$editable.data("orgHeight") }), this.$editable.css("maxHeight", this.$editable.css("orgMaxHeight"))), this.context.invoke("toolbar.updateFullscreen", t);
  }
  isFullscreen() {
    return this.$editor.hasClass("fullscreen");
  }
  destroy() {
    this.$scrollbar.removeClass(this.scrollbarClassName);
  }
}
class Qo {
  constructor(t) {
    this.context = t, this.$document = l(document), this.$editingArea = t.layoutInfo.editingArea, this.options = t.options, this.lang = this.options.langInfo, this.events = {
      "summernote.mousedown": (e, o) => {
        this.update(o.target, o) && o.preventDefault();
      },
      "summernote.keyup summernote.scroll summernote.change summernote.dialog.shown": () => {
        this.update();
      },
      "summernote.disable summernote.blur": () => {
        this.hide();
      },
      "summernote.codeview.toggled": () => {
        this.update();
      }
    };
  }
  initialize() {
    this.$handle = l([
      '<div class="note-handle">',
      '<div class="note-control-selection">',
      '<div class="note-control-selection-bg"></div>',
      '<div class="note-control-holder note-control-nw"></div>',
      '<div class="note-control-holder note-control-ne"></div>',
      '<div class="note-control-holder note-control-sw"></div>',
      '<div class="',
      this.options.disableResizeImage ? "note-control-holder" : "note-control-sizing",
      ' note-control-se"></div>',
      this.options.disableResizeImage ? "" : '<div class="note-control-selection-info"></div>',
      "</div>",
      "</div>"
    ].join("")).prependTo(this.$editingArea), this.$handle.on("mousedown", (t) => {
      if (r.isControlSizing(t.target)) {
        t.preventDefault(), t.stopPropagation();
        const e = this.$handle.find(".note-control-selection").data("target"), o = e.offset(), n = this.$document.scrollTop(), s = (a) => {
          this.context.invoke("editor.resizeTo", {
            x: a.clientX - o.left,
            y: a.clientY - (o.top - n)
          }, e, !a.shiftKey), this.update(e[0], a);
        };
        this.$document.on("mousemove", s).one("mouseup", (a) => {
          a.preventDefault(), this.$document.off("mousemove", s), this.context.invoke("editor.afterCommand");
        }), e.data("ratio") || e.data("ratio", e.height() / e.width());
      }
    }), this.$handle.on("wheel", (t) => {
      t.preventDefault(), this.update();
    });
  }
  destroy() {
    this.$handle.remove();
  }
  update(t, e) {
    if (this.context.isDisabled())
      return !1;
    const o = r.isImg(t), n = this.$handle.find(".note-control-selection");
    if (this.context.invoke("imagePopover.update", t, e), o) {
      const s = l(t), a = this.$editingArea[0].getBoundingClientRect(), c = t.getBoundingClientRect();
      n.css({
        display: "block",
        left: c.left - a.left,
        top: c.top - a.top,
        width: c.width,
        height: c.height
      }).data("target", s);
      const d = new Image();
      d.src = s.attr("src");
      const h = c.width + "x" + c.height + " (" + this.lang.image.original + ": " + d.width + "x" + d.height + ")";
      n.find(".note-control-selection-info").text(h), this.context.invoke("editor.saveTarget", t);
    } else
      this.hide();
    return o;
  }
  /**
   * hide
   *
   * @param {jQuery} $handle
   */
  hide() {
    this.context.invoke("editor.clearTarget"), this.$handle.children().hide();
  }
}
const Jo = "http://", ti = /^([A-Za-z][A-Za-z0-9+-.]*\:[\/]{2}|tel:|mailto:[A-Z0-9._%+-]+@|xmpp:[A-Z0-9._%+-]+@)?(www\.)?(.+)$/i;
class ei {
  constructor(t) {
    this.context = t, this.options = t.options, this.$editable = t.layoutInfo.editable, this.events = {
      "summernote.keyup": (e, o) => {
        o.isDefaultPrevented() || this.handleKeyup(o);
      },
      "summernote.keydown": (e, o) => {
        this.handleKeydown(o);
      }
    };
  }
  initialize() {
    this.lastWordRange = null;
  }
  destroy() {
    this.lastWordRange = null;
  }
  replace() {
    if (!this.lastWordRange)
      return;
    const t = this.lastWordRange.toString(), e = t.match(ti);
    if (e && (e[1] || e[2])) {
      const o = e[1] ? t : Jo + t, n = this.options.showDomainOnlyForAutolink ? t.replace(/^(?:https?:\/\/)?(?:tel?:?)?(?:mailto?:?)?(?:xmpp?:?)?(?:www\.)?/i, "").split("/")[0] : t, s = l("<a></a>").html(n).attr("href", o)[0];
      this.context.options.linkTargetBlank && l(s).attr("target", "_blank"), this.lastWordRange.insertNode(s), this.lastWordRange = null, this.context.invoke("editor.focus"), this.context.triggerEvent("change", this.$editable.html(), this.$editable);
    }
  }
  handleKeydown(t) {
    if (f.contains([x.code.ENTER, x.code.SPACE], t.keyCode)) {
      const e = this.context.invoke("editor.createRange").getWordRange();
      this.lastWordRange = e;
    }
  }
  handleKeyup(t) {
    (x.code.SPACE === t.keyCode || x.code.ENTER === t.keyCode && !t.shiftKey) && this.replace();
  }
}
class oi {
  constructor(t) {
    this.$note = t.layoutInfo.note, this.events = {
      "summernote.change": () => {
        this.$note.val(t.invoke("code"));
      }
    };
  }
  shouldInitialize() {
    return r.isTextarea(this.$note[0]);
  }
}
class ii {
  constructor(t) {
    this.context = t, this.options = t.options.replace || {}, this.keys = [x.code.ENTER, x.code.SPACE, x.code.PERIOD, x.code.COMMA, x.code.SEMICOLON, x.code.SLASH], this.previousKeydownCode = null, this.events = {
      "summernote.keyup": (e, o) => {
        o.isDefaultPrevented() || this.handleKeyup(o);
      },
      "summernote.keydown": (e, o) => {
        this.handleKeydown(o);
      }
    };
  }
  shouldInitialize() {
    return !!this.options.match;
  }
  initialize() {
    this.lastWord = null;
  }
  destroy() {
    this.lastWord = null;
  }
  replace() {
    if (!this.lastWord)
      return;
    const t = this, e = this.lastWord.toString();
    this.options.match(e, function(o) {
      if (o) {
        let n = "";
        if (typeof o == "string" ? n = r.createText(o) : o instanceof jQuery ? n = o[0] : o instanceof Node && (n = o), !n) return;
        t.lastWord.insertNode(n), t.lastWord = null, t.context.invoke("editor.focus");
      }
    });
  }
  handleKeydown(t) {
    if (this.previousKeydownCode && f.contains(this.keys, this.previousKeydownCode)) {
      this.previousKeydownCode = t.keyCode;
      return;
    }
    if (f.contains(this.keys, t.keyCode)) {
      const e = this.context.invoke("editor.createRange").getWordRange();
      this.lastWord = e;
    }
    this.previousKeydownCode = t.keyCode;
  }
  handleKeyup(t) {
    f.contains(this.keys, t.keyCode) && this.replace();
  }
}
class ni {
  constructor(t) {
    this.context = t, this.$editingArea = t.layoutInfo.editingArea, this.options = t.options, this.options.inheritPlaceholder === !0 && (this.options.placeholder = this.context.$note.attr("placeholder") || this.options.placeholder), this.events = {
      "summernote.init summernote.change": () => {
        this.update();
      },
      "summernote.codeview.toggled": () => {
        this.update();
      }
    };
  }
  shouldInitialize() {
    return !!this.options.placeholder;
  }
  initialize() {
    this.$placeholder = l('<div class="note-placeholder"></div>'), this.$placeholder.on("click", () => {
      this.context.invoke("focus");
    }).html(this.options.placeholder).prependTo(this.$editingArea), this.update();
  }
  destroy() {
    this.$placeholder.remove();
  }
  update() {
    const t = !this.context.invoke("codeview.isActivated") && this.context.invoke("editor.isEmpty");
    this.$placeholder.toggle(t);
  }
}
class si {
  constructor(t) {
    this.ui = l.summernote.ui, this.context = t, this.$toolbar = t.layoutInfo.toolbar, this.options = t.options, this.lang = this.options.langInfo, this.invertedKeyMap = v.invertObject(
      this.options.keyMap[$.isMac ? "mac" : "pc"]
    );
  }
  representShortcut(t) {
    let e = this.invertedKeyMap[t];
    return !this.options.shortcuts || !e ? "" : ($.isMac && (e = e.replace("CMD", "â").replace("SHIFT", "â§")), e = e.replace("BACKSLASH", "\\").replace("SLASH", "/").replace("LEFTBRACKET", "[").replace("RIGHTBRACKET", "]"), " (" + e + ")");
  }
  button(t) {
    return !this.options.tooltip && t.tooltip && delete t.tooltip, t.container = this.options.container, this.ui.button(t);
  }
  initialize() {
    this.addToolbarButtons(), this.addImagePopoverButtons(), this.addLinkPopoverButtons(), this.addTablePopoverButtons(), this.fontInstalledMap = {};
  }
  destroy() {
    delete this.fontInstalledMap;
  }
  isFontInstalled(t) {
    return Object.prototype.hasOwnProperty.call(this.fontInstalledMap, t) || (this.fontInstalledMap[t] = $.isFontInstalled(t) || f.contains(this.options.fontNamesIgnoreCheck, t)), this.fontInstalledMap[t];
  }
  isFontDeservedToAdd(t) {
    return t = t.toLowerCase(), t !== "" && this.isFontInstalled(t) && $.genericFontFamilies.indexOf(t) === -1;
  }
  colorPalette(t, e, o, n) {
    return this.ui.buttonGroup({
      className: "note-color " + t,
      children: [
        this.button({
          className: "note-current-color-button",
          contents: this.ui.icon(this.options.icons.font + " note-recent-color"),
          tooltip: e,
          click: (s) => {
            const a = l(s.currentTarget);
            o && n ? this.context.invoke("editor.color", {
              backColor: a.attr("data-backColor"),
              foreColor: a.attr("data-foreColor")
            }) : o ? this.context.invoke("editor.color", {
              backColor: a.attr("data-backColor")
            }) : n && this.context.invoke("editor.color", {
              foreColor: a.attr("data-foreColor")
            });
          },
          callback: (s) => {
            const a = s.find(".note-recent-color");
            o && (a.css("background-color", this.options.colorButton.backColor), s.attr("data-backColor", this.options.colorButton.backColor)), n ? (a.css("color", this.options.colorButton.foreColor), s.attr("data-foreColor", this.options.colorButton.foreColor)) : a.css("color", "transparent");
          }
        }),
        this.button({
          className: "dropdown-toggle",
          contents: this.ui.dropdownButtonContents("", this.options),
          tooltip: this.lang.color.more,
          data: {
            toggle: "dropdown"
          }
        }),
        this.ui.dropdown({
          items: (o ? [
            '<div class="note-palette">',
            '<div class="note-palette-title">' + this.lang.color.background + "</div>",
            "<div>",
            '<button type="button" class="note-color-reset btn btn-light btn-default" data-event="backColor" data-value="transparent">',
            this.lang.color.transparent,
            "</button>",
            "</div>",
            '<div class="note-holder" data-event="backColor"><!-- back colors --></div>',
            "<div>",
            '<button type="button" class="note-color-select btn btn-light btn-default" data-event="openPalette" data-value="backColorPicker-' + this.options.id + '">',
            this.lang.color.cpSelect,
            "</button>",
            '<input type="color" id="backColorPicker-' + this.options.id + '" class="note-btn note-color-select-btn" value="' + this.options.colorButton.backColor + '" data-event="backColorPalette-' + this.options.id + '">',
            "</div>",
            '<div class="note-holder-custom" id="backColorPalette-' + this.options.id + '" data-event="backColor"></div>',
            "</div>"
          ].join("") : "") + (n ? [
            '<div class="note-palette">',
            '<div class="note-palette-title">' + this.lang.color.foreground + "</div>",
            "<div>",
            '<button type="button" class="note-color-reset btn btn-light btn-default" data-event="removeFormat" data-value="foreColor">',
            this.lang.color.resetToDefault,
            "</button>",
            "</div>",
            '<div class="note-holder" data-event="foreColor"><!-- fore colors --></div>',
            "<div>",
            '<button type="button" class="note-color-select btn btn-light btn-default" data-event="openPalette" data-value="foreColorPicker-' + this.options.id + '">',
            this.lang.color.cpSelect,
            "</button>",
            '<input type="color" id="foreColorPicker-' + this.options.id + '" class="note-btn note-color-select-btn" value="' + this.options.colorButton.foreColor + '" data-event="foreColorPalette-' + this.options.id + '">',
            "</div>",
            // Fix missing Div, Commented to find easily if it's wrong
            '<div class="note-holder-custom" id="foreColorPalette-' + this.options.id + '" data-event="foreColor"></div>',
            "</div>"
          ].join("") : ""),
          callback: (s) => {
            s.find(".note-holder").each((c, d) => {
              const h = l(d);
              h.append(this.ui.palette({
                colors: this.options.colors,
                colorsName: this.options.colorsName,
                eventName: h.data("event"),
                container: this.options.container,
                tooltip: this.options.tooltip
              }).render());
            });
            var a = [
              ["#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF"]
            ];
            s.find(".note-holder-custom").each((c, d) => {
              const h = l(d);
              h.append(this.ui.palette({
                colors: a,
                colorsName: a,
                eventName: h.data("event"),
                container: this.options.container,
                tooltip: this.options.tooltip
              }).render());
            }), s.find("input[type=color]").each((c, d) => {
              l(d).on("change", function() {
                const h = s.find("#" + l(this).data("event")).find(".note-color-btn").first(), u = this.value.toUpperCase();
                h.css("background-color", u).attr("aria-label", u).attr("data-value", u).attr("data-original-title", u), h.trigger("click");
              });
            });
          },
          click: (s) => {
            s.stopPropagation();
            const a = l("." + t).find(".note-dropdown-menu"), c = l(s.target), d = c.data("event"), h = c.attr("data-value");
            if (d === "openPalette") {
              const u = a.find("#" + h), p = l(a.find("#" + u.data("event")).find(".note-color-row")[0]), k = p.find(".note-color-btn").last().detach(), C = u.val();
              k.css("background-color", C).attr("aria-label", C).attr("data-value", C).attr("data-original-title", C), p.prepend(k), u.trigger("click");
            } else {
              if (f.contains(["backColor", "foreColor"], d)) {
                const u = d === "backColor" ? "background-color" : "color", p = c.closest(".note-color").find(".note-recent-color"), k = c.closest(".note-color").find(".note-current-color-button");
                p.css(u, h), k.attr("data-" + d, h);
              }
              this.context.invoke("editor." + d, h);
            }
          }
        })
      ]
    }).render();
  }
  addToolbarButtons() {
    this.context.memo("button.style", () => this.ui.buttonGroup([
      this.button({
        className: "dropdown-toggle",
        contents: this.ui.dropdownButtonContents(
          this.ui.icon(this.options.icons.magic),
          this.options
        ),
        tooltip: this.lang.style.style,
        data: {
          toggle: "dropdown"
        }
      }),
      this.ui.dropdown({
        className: "dropdown-style",
        items: this.options.styleTags,
        title: this.lang.style.style,
        template: (c) => {
          typeof c == "string" && (c = {
            tag: c,
            title: Object.prototype.hasOwnProperty.call(this.lang.style, c) ? this.lang.style[c] : c
          });
          const d = c.tag, h = c.title, u = c.style ? ' style="' + c.style + '" ' : "", p = c.className ? ' class="' + c.className + '"' : "";
          return "<" + d + u + p + ">" + h + "</" + d + ">";
        },
        click: this.context.createInvokeHandler("editor.formatBlock")
      })
    ]).render());
    for (let c = 0, d = this.options.styleTags.length; c < d; c++) {
      const h = this.options.styleTags[c];
      this.context.memo("button.style." + h, () => this.button({
        className: "note-btn-style-" + h,
        contents: '<div data-value="' + h + '">' + h.toUpperCase() + "</div>",
        tooltip: this.lang.style[h],
        click: this.context.createInvokeHandler("editor.formatBlock")
      }).render());
    }
    this.context.memo("button.bold", () => this.button({
      className: "note-btn-bold",
      contents: this.ui.icon(this.options.icons.bold),
      tooltip: this.lang.font.bold + this.representShortcut("bold"),
      click: this.context.createInvokeHandlerAndUpdateState("editor.bold")
    }).render()), this.context.memo("button.italic", () => this.button({
      className: "note-btn-italic",
      contents: this.ui.icon(this.options.icons.italic),
      tooltip: this.lang.font.italic + this.representShortcut("italic"),
      click: this.context.createInvokeHandlerAndUpdateState("editor.italic")
    }).render()), this.context.memo("button.underline", () => this.button({
      className: "note-btn-underline",
      contents: this.ui.icon(this.options.icons.underline),
      tooltip: this.lang.font.underline + this.representShortcut("underline"),
      click: this.context.createInvokeHandlerAndUpdateState("editor.underline")
    }).render()), this.context.memo("button.clear", () => this.button({
      contents: this.ui.icon(this.options.icons.eraser),
      tooltip: this.lang.font.clear + this.representShortcut("removeFormat"),
      click: this.context.createInvokeHandler("editor.removeFormat")
    }).render()), this.context.memo("button.strikethrough", () => this.button({
      className: "note-btn-strikethrough",
      contents: this.ui.icon(this.options.icons.strikethrough),
      tooltip: this.lang.font.strikethrough + this.representShortcut("strikethrough"),
      click: this.context.createInvokeHandlerAndUpdateState("editor.strikethrough")
    }).render()), this.context.memo("button.superscript", () => this.button({
      className: "note-btn-superscript",
      contents: this.ui.icon(this.options.icons.superscript),
      tooltip: this.lang.font.superscript,
      click: this.context.createInvokeHandlerAndUpdateState("editor.superscript")
    }).render()), this.context.memo("button.subscript", () => this.button({
      className: "note-btn-subscript",
      contents: this.ui.icon(this.options.icons.subscript),
      tooltip: this.lang.font.subscript,
      click: this.context.createInvokeHandlerAndUpdateState("editor.subscript")
    }).render()), this.context.memo("button.fontname", () => {
      const c = this.context.invoke("editor.currentStyle");
      return this.options.addDefaultFonts && l.each(c["font-family"].split(","), (d, h) => {
        h = h.trim().replace(/['"]+/g, ""), this.isFontDeservedToAdd(h) && this.options.fontNames.indexOf(h) === -1 && this.options.fontNames.push(h);
      }), this.ui.buttonGroup([
        this.button({
          className: "dropdown-toggle",
          contents: this.ui.dropdownButtonContents(
            '<span class="note-current-fontname"></span>',
            this.options
          ),
          tooltip: this.lang.font.name,
          data: {
            toggle: "dropdown"
          }
        }),
        this.ui.dropdownCheck({
          className: "dropdown-fontname",
          checkClassName: this.options.icons.menuCheck,
          items: this.options.fontNames.filter(this.isFontInstalled.bind(this)),
          title: this.lang.font.name,
          template: (d) => '<span style="font-family: ' + $.validFontName(d) + '">' + d + "</span>",
          click: this.context.createInvokeHandlerAndUpdateState("editor.fontName")
        })
      ]).render();
    }), this.context.memo("button.fontsize", () => this.ui.buttonGroup([
      this.button({
        className: "dropdown-toggle",
        contents: this.ui.dropdownButtonContents('<span class="note-current-fontsize"></span>', this.options),
        tooltip: this.lang.font.size,
        data: {
          toggle: "dropdown"
        }
      }),
      this.ui.dropdownCheck({
        className: "dropdown-fontsize",
        checkClassName: this.options.icons.menuCheck,
        items: this.options.fontSizes,
        title: this.lang.font.size,
        click: this.context.createInvokeHandlerAndUpdateState("editor.fontSize")
      })
    ]).render()), this.context.memo("button.fontsizeunit", () => this.ui.buttonGroup([
      this.button({
        className: "dropdown-toggle",
        contents: this.ui.dropdownButtonContents('<span class="note-current-fontsizeunit"></span>', this.options),
        tooltip: this.lang.font.sizeunit,
        data: {
          toggle: "dropdown"
        }
      }),
      this.ui.dropdownCheck({
        className: "dropdown-fontsizeunit",
        checkClassName: this.options.icons.menuCheck,
        items: this.options.fontSizeUnits,
        title: this.lang.font.sizeunit,
        click: this.context.createInvokeHandlerAndUpdateState("editor.fontSizeUnit")
      })
    ]).render()), this.context.memo("button.color", () => this.colorPalette("note-color-all", this.lang.color.recent, !0, !0)), this.context.memo("button.forecolor", () => this.colorPalette("note-color-fore", this.lang.color.foreground, !1, !0)), this.context.memo("button.backcolor", () => this.colorPalette("note-color-back", this.lang.color.background, !0, !1)), this.context.memo("button.ul", () => this.button({
      contents: this.ui.icon(this.options.icons.unorderedlist),
      tooltip: this.lang.lists.unordered + this.representShortcut("insertUnorderedList"),
      click: this.context.createInvokeHandler("editor.insertUnorderedList")
    }).render()), this.context.memo("button.ol", () => this.button({
      contents: this.ui.icon(this.options.icons.orderedlist),
      tooltip: this.lang.lists.ordered + this.representShortcut("insertOrderedList"),
      click: this.context.createInvokeHandler("editor.insertOrderedList")
    }).render());
    const t = this.button({
      contents: this.ui.icon(this.options.icons.alignLeft),
      tooltip: this.lang.paragraph.left + this.representShortcut("justifyLeft"),
      click: this.context.createInvokeHandler("editor.justifyLeft")
    }), e = this.button({
      contents: this.ui.icon(this.options.icons.alignCenter),
      tooltip: this.lang.paragraph.center + this.representShortcut("justifyCenter"),
      click: this.context.createInvokeHandler("editor.justifyCenter")
    }), o = this.button({
      contents: this.ui.icon(this.options.icons.alignRight),
      tooltip: this.lang.paragraph.right + this.representShortcut("justifyRight"),
      click: this.context.createInvokeHandler("editor.justifyRight")
    }), n = this.button({
      contents: this.ui.icon(this.options.icons.alignJustify),
      tooltip: this.lang.paragraph.justify + this.representShortcut("justifyFull"),
      click: this.context.createInvokeHandler("editor.justifyFull")
    }), s = this.button({
      contents: this.ui.icon(this.options.icons.outdent),
      tooltip: this.lang.paragraph.outdent + this.representShortcut("outdent"),
      click: this.context.createInvokeHandler("editor.outdent")
    }), a = this.button({
      contents: this.ui.icon(this.options.icons.indent),
      tooltip: this.lang.paragraph.indent + this.representShortcut("indent"),
      click: this.context.createInvokeHandler("editor.indent")
    });
    this.context.memo("button.justifyLeft", v.invoke(t, "render")), this.context.memo("button.justifyCenter", v.invoke(e, "render")), this.context.memo("button.justifyRight", v.invoke(o, "render")), this.context.memo("button.justifyFull", v.invoke(n, "render")), this.context.memo("button.outdent", v.invoke(s, "render")), this.context.memo("button.indent", v.invoke(a, "render")), this.context.memo("button.paragraph", () => this.ui.buttonGroup([
      this.button({
        className: "dropdown-toggle",
        contents: this.ui.dropdownButtonContents(this.ui.icon(this.options.icons.alignLeft), this.options),
        tooltip: this.lang.paragraph.paragraph,
        data: {
          toggle: "dropdown"
        }
      }),
      this.ui.dropdown([
        this.ui.buttonGroup({
          className: "note-align",
          children: [t, e, o, n]
        }),
        this.ui.buttonGroup({
          className: "note-list",
          children: [s, a]
        })
      ])
    ]).render()), this.context.memo("button.height", () => this.ui.buttonGroup([
      this.button({
        className: "dropdown-toggle",
        contents: this.ui.dropdownButtonContents(this.ui.icon(this.options.icons.textHeight), this.options),
        tooltip: this.lang.font.height,
        data: {
          toggle: "dropdown"
        }
      }),
      this.ui.dropdownCheck({
        items: this.options.lineHeights,
        checkClassName: this.options.icons.menuCheck,
        className: "dropdown-line-height",
        title: this.lang.font.height,
        click: this.context.createInvokeHandler("editor.lineHeight")
      })
    ]).render()), this.context.memo("button.table", () => this.ui.buttonGroup([
      this.button({
        className: "dropdown-toggle",
        contents: this.ui.dropdownButtonContents(this.ui.icon(this.options.icons.table), this.options),
        tooltip: this.lang.table.table,
        data: {
          toggle: "dropdown"
        }
      }),
      this.ui.dropdown({
        title: this.lang.table.table,
        className: "note-table",
        items: [
          '<div class="note-dimension-picker">',
          '<div class="note-dimension-picker-mousecatcher" data-event="insertTable" data-value="1x1"></div>',
          '<div class="note-dimension-picker-highlighted"></div>',
          '<div class="note-dimension-picker-unhighlighted"></div>',
          "</div>",
          '<div class="note-dimension-display">1 x 1</div>'
        ].join("")
      })
    ], {
      callback: (c) => {
        c.find(".note-dimension-picker-mousecatcher").css({
          width: this.options.insertTableMaxSize.col + "em",
          height: this.options.insertTableMaxSize.row + "em"
        }).on("mouseup", this.context.createInvokeHandler("editor.insertTable")).on("mousemove", this.tableMoveHandler.bind(this));
      }
    }).render()), this.context.memo("button.link", () => this.button({
      contents: this.ui.icon(this.options.icons.link),
      tooltip: this.lang.link.link + this.representShortcut("linkDialog.show"),
      click: this.context.createInvokeHandler("linkDialog.show")
    }).render()), this.context.memo("button.picture", () => this.button({
      contents: this.ui.icon(this.options.icons.picture),
      tooltip: this.lang.image.image,
      click: this.context.createInvokeHandler("imageDialog.show")
    }).render()), this.context.memo("button.video", () => this.button({
      contents: this.ui.icon(this.options.icons.video),
      tooltip: this.lang.video.video,
      click: this.context.createInvokeHandler("videoDialog.show")
    }).render()), this.context.memo("button.hr", () => this.button({
      contents: this.ui.icon(this.options.icons.minus),
      tooltip: this.lang.hr.insert + this.representShortcut("insertHorizontalRule"),
      click: this.context.createInvokeHandler("editor.insertHorizontalRule")
    }).render()), this.context.memo("button.fullscreen", () => this.button({
      className: "btn-fullscreen note-codeview-keep",
      contents: this.ui.icon(this.options.icons.arrowsAlt),
      tooltip: this.lang.options.fullscreen,
      click: this.context.createInvokeHandler("fullscreen.toggle")
    }).render()), this.context.memo("button.codeview", () => this.button({
      className: "btn-codeview note-codeview-keep",
      contents: this.ui.icon(this.options.icons.code),
      tooltip: this.lang.options.codeview,
      click: this.context.createInvokeHandler("codeview.toggle")
    }).render()), this.context.memo("button.redo", () => this.button({
      contents: this.ui.icon(this.options.icons.redo),
      tooltip: this.lang.history.redo + this.representShortcut("redo"),
      click: this.context.createInvokeHandler("editor.redo")
    }).render()), this.context.memo("button.undo", () => this.button({
      contents: this.ui.icon(this.options.icons.undo),
      tooltip: this.lang.history.undo + this.representShortcut("undo"),
      click: this.context.createInvokeHandler("editor.undo")
    }).render()), this.context.memo("button.help", () => this.button({
      contents: this.ui.icon(this.options.icons.question),
      tooltip: this.lang.options.help,
      click: this.context.createInvokeHandler("helpDialog.show")
    }).render());
  }
  /**
   * image: [
   *   ['imageResize', ['resizeFull', 'resizeHalf', 'resizeQuarter', 'resizeNone']],
   *   ['float', ['floatLeft', 'floatRight', 'floatNone']],
   *   ['remove', ['removeMedia']],
   * ],
   */
  addImagePopoverButtons() {
    this.context.memo("button.resizeFull", () => this.button({
      contents: '<span class="note-fontsize-10">100%</span>',
      tooltip: this.lang.image.resizeFull,
      click: this.context.createInvokeHandler("editor.resize", "1")
    }).render()), this.context.memo("button.resizeHalf", () => this.button({
      contents: '<span class="note-fontsize-10">50%</span>',
      tooltip: this.lang.image.resizeHalf,
      click: this.context.createInvokeHandler("editor.resize", "0.5")
    }).render()), this.context.memo("button.resizeQuarter", () => this.button({
      contents: '<span class="note-fontsize-10">25%</span>',
      tooltip: this.lang.image.resizeQuarter,
      click: this.context.createInvokeHandler("editor.resize", "0.25")
    }).render()), this.context.memo("button.resizeNone", () => this.button({
      contents: this.ui.icon(this.options.icons.rollback),
      tooltip: this.lang.image.resizeNone,
      click: this.context.createInvokeHandler("editor.resize", "0")
    }).render()), this.context.memo("button.floatLeft", () => this.button({
      contents: this.ui.icon(this.options.icons.floatLeft),
      tooltip: this.lang.image.floatLeft,
      click: this.context.createInvokeHandler("editor.floatMe", "left")
    }).render()), this.context.memo("button.floatRight", () => this.button({
      contents: this.ui.icon(this.options.icons.floatRight),
      tooltip: this.lang.image.floatRight,
      click: this.context.createInvokeHandler("editor.floatMe", "right")
    }).render()), this.context.memo("button.floatNone", () => this.button({
      contents: this.ui.icon(this.options.icons.rollback),
      tooltip: this.lang.image.floatNone,
      click: this.context.createInvokeHandler("editor.floatMe", "none")
    }).render()), this.context.memo("button.removeMedia", () => this.button({
      contents: this.ui.icon(this.options.icons.trash),
      tooltip: this.lang.image.remove,
      click: this.context.createInvokeHandler("editor.removeMedia")
    }).render());
  }
  addLinkPopoverButtons() {
    this.context.memo("button.linkDialogShow", () => this.button({
      contents: this.ui.icon(this.options.icons.link),
      tooltip: this.lang.link.edit,
      click: this.context.createInvokeHandler("linkDialog.show")
    }).render()), this.context.memo("button.unlink", () => this.button({
      contents: this.ui.icon(this.options.icons.unlink),
      tooltip: this.lang.link.unlink,
      click: this.context.createInvokeHandler("editor.unlink")
    }).render());
  }
  /**
   * table : [
   *  ['add', ['addRowDown', 'addRowUp', 'addColLeft', 'addColRight']],
   *  ['delete', ['deleteRow', 'deleteCol', 'deleteTable']]
   * ],
   */
  addTablePopoverButtons() {
    this.context.memo("button.addRowUp", () => this.button({
      className: "btn-md",
      contents: this.ui.icon(this.options.icons.rowAbove),
      tooltip: this.lang.table.addRowAbove,
      click: this.context.createInvokeHandler("editor.addRow", "top")
    }).render()), this.context.memo("button.addRowDown", () => this.button({
      className: "btn-md",
      contents: this.ui.icon(this.options.icons.rowBelow),
      tooltip: this.lang.table.addRowBelow,
      click: this.context.createInvokeHandler("editor.addRow", "bottom")
    }).render()), this.context.memo("button.addColLeft", () => this.button({
      className: "btn-md",
      contents: this.ui.icon(this.options.icons.colBefore),
      tooltip: this.lang.table.addColLeft,
      click: this.context.createInvokeHandler("editor.addCol", "left")
    }).render()), this.context.memo("button.addColRight", () => this.button({
      className: "btn-md",
      contents: this.ui.icon(this.options.icons.colAfter),
      tooltip: this.lang.table.addColRight,
      click: this.context.createInvokeHandler("editor.addCol", "right")
    }).render()), this.context.memo("button.deleteRow", () => this.button({
      className: "btn-md",
      contents: this.ui.icon(this.options.icons.rowRemove),
      tooltip: this.lang.table.delRow,
      click: this.context.createInvokeHandler("editor.deleteRow")
    }).render()), this.context.memo("button.deleteCol", () => this.button({
      className: "btn-md",
      contents: this.ui.icon(this.options.icons.colRemove),
      tooltip: this.lang.table.delCol,
      click: this.context.createInvokeHandler("editor.deleteCol")
    }).render()), this.context.memo("button.deleteTable", () => this.button({
      className: "btn-md",
      contents: this.ui.icon(this.options.icons.trash),
      tooltip: this.lang.table.delTable,
      click: this.context.createInvokeHandler("editor.deleteTable")
    }).render());
  }
  build(t, e) {
    for (let o = 0, n = e.length; o < n; o++) {
      const s = e[o], a = Array.isArray(s) ? s[0] : s, c = Array.isArray(s) ? s.length === 1 ? [s[0]] : s[1] : [s], d = this.ui.buttonGroup({
        className: "note-" + a
      }).render();
      for (let h = 0, u = c.length; h < u; h++) {
        const p = this.context.memo("button." + c[h]);
        p && d.append(typeof p == "function" ? p(this.context) : p);
      }
      d.appendTo(t);
    }
  }
  /**
   * @param {jQuery} [$container]
   */
  updateCurrentStyle(t) {
    const e = t || this.$toolbar, o = this.context.invoke("editor.currentStyle");
    if (this.updateBtnStates(e, {
      ".note-btn-bold": () => o["font-bold"] === "bold",
      ".note-btn-italic": () => o["font-italic"] === "italic",
      ".note-btn-underline": () => o["font-underline"] === "underline",
      ".note-btn-subscript": () => o["font-subscript"] === "subscript",
      ".note-btn-superscript": () => o["font-superscript"] === "superscript",
      ".note-btn-strikethrough": () => o["font-strikethrough"] === "strikethrough"
    }), o["font-family"]) {
      const n = o["font-family"].split(",").map((a) => a.replace(/[\'\"]/g, "").replace(/\s+$/, "").replace(/^\s+/, "")), s = f.find(n, this.isFontInstalled.bind(this));
      e.find(".dropdown-fontname a").each((a, c) => {
        const d = l(c), h = d.data("value") + "" == s + "";
        d.toggleClass("checked", h);
      }), e.find(".note-current-fontname").text(s).css("font-family", s);
    }
    if (o["font-size"]) {
      const n = o["font-size"];
      e.find(".dropdown-fontsize a").each((a, c) => {
        const d = l(c), h = d.data("value") + "" == n + "";
        d.toggleClass("checked", h);
      }), e.find(".note-current-fontsize").text(n);
      const s = o["font-size-unit"];
      e.find(".dropdown-fontsizeunit a").each((a, c) => {
        const d = l(c), h = d.data("value") + "" == s + "";
        d.toggleClass("checked", h);
      }), e.find(".note-current-fontsizeunit").text(s);
    }
    if (o["line-height"]) {
      const n = o["line-height"];
      e.find(".dropdown-line-height a").each((s, a) => {
        const c = l(a), d = l(a).data("value") + "" == n + "";
        c.toggleClass("checked", d);
      }), e.find(".note-current-line-height").text(n);
    }
  }
  updateBtnStates(t, e) {
    l.each(e, (o, n) => {
      this.ui.toggleBtnActive(t.find(o), n());
    });
  }
  tableMoveHandler(t) {
    const o = l(t.target.parentNode), n = o.next(), s = o.find(".note-dimension-picker-mousecatcher"), a = o.find(".note-dimension-picker-highlighted"), c = o.find(".note-dimension-picker-unhighlighted");
    let d;
    if (t.offsetX === void 0) {
      const u = l(t.target).offset();
      d = {
        x: t.pageX - u.left,
        y: t.pageY - u.top
      };
    } else
      d = {
        x: t.offsetX,
        y: t.offsetY
      };
    const h = {
      c: Math.ceil(d.x / 18) || 1,
      r: Math.ceil(d.y / 18) || 1
    };
    a.css({ width: h.c + "em", height: h.r + "em" }), s.data("value", h.c + "x" + h.r), h.c > 3 && h.c < this.options.insertTableMaxSize.col && c.css({ width: h.c + 1 + "em" }), h.r > 3 && h.r < this.options.insertTableMaxSize.row && c.css({ height: h.r + 1 + "em" }), n.html(h.c + " x " + h.r);
  }
}
class ri {
  constructor(t) {
    this.context = t, this.$window = l(window), this.$document = l(document), this.ui = l.summernote.ui, this.$note = t.layoutInfo.note, this.$editor = t.layoutInfo.editor, this.$toolbar = t.layoutInfo.toolbar, this.$editable = t.layoutInfo.editable, this.$statusbar = t.layoutInfo.statusbar, this.options = t.options, this.isFollowing = !1, this.followScroll = this.followScroll.bind(this);
  }
  shouldInitialize() {
    return !this.options.airMode;
  }
  initialize() {
    this.options.toolbar = this.options.toolbar || [], this.options.toolbar.length ? this.context.invoke("buttons.build", this.$toolbar, this.options.toolbar) : this.$toolbar.hide(), this.options.toolbarContainer && this.$toolbar.appendTo(this.options.toolbarContainer), this.changeContainer(!1), this.$note.on("summernote.keyup summernote.mouseup summernote.change", () => {
      this.context.invoke("buttons.updateCurrentStyle");
    }), this.context.invoke("buttons.updateCurrentStyle"), this.options.followingToolbar && this.$window.on("scroll resize", this.followScroll);
  }
  destroy() {
    this.$toolbar.children().remove(), this.options.followingToolbar && this.$window.off("scroll resize", this.followScroll);
  }
  followScroll() {
    if (this.$editor.hasClass("fullscreen"))
      return !1;
    const t = this.$editor.outerHeight(), e = this.$editor.width(), o = this.$toolbar.height(), n = this.$statusbar.height();
    let s = 0;
    this.options.otherStaticBar && (s = l(this.options.otherStaticBar).outerHeight());
    const a = this.$document.scrollTop(), c = this.$editor.offset().top, d = c + t, h = c - s, u = d - s - o - n;
    !this.isFollowing && a > h && a < u - o ? (this.isFollowing = !0, this.$editable.css({
      marginTop: this.$toolbar.outerHeight()
    }), this.$toolbar.css({
      position: "fixed",
      top: s,
      width: e,
      zIndex: 1e3
    })) : this.isFollowing && (a < h || a > u) && (this.isFollowing = !1, this.$toolbar.css({
      position: "relative",
      top: 0,
      width: "100%",
      zIndex: "auto"
    }), this.$editable.css({
      marginTop: ""
    }));
  }
  changeContainer(t) {
    t ? this.$toolbar.prependTo(this.$editor) : this.options.toolbarContainer && this.$toolbar.appendTo(this.options.toolbarContainer), this.options.followingToolbar && this.followScroll();
  }
  updateFullscreen(t) {
    this.ui.toggleBtnActive(this.$toolbar.find(".btn-fullscreen"), t), this.changeContainer(t);
  }
  updateCodeview(t) {
    this.ui.toggleBtnActive(this.$toolbar.find(".btn-codeview"), t), t ? this.deactivate() : this.activate();
  }
  activate(t) {
    let e = this.$toolbar.find("button");
    t || (e = e.not(".note-codeview-keep")), this.ui.toggleBtn(e, !0);
  }
  deactivate(t) {
    let e = this.$toolbar.find("button");
    t || (e = e.not(".note-codeview-keep")), this.ui.toggleBtn(e, !1);
  }
}
const ai = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/, li = /^(\+?\d{1,3}[\s-]?)?(\d{1,4})[\s-]?(\d{1,4})[\s-]?(\d{1,4})$/, ci = /^([A-Za-z][A-Za-z0-9+-.]*\:|#|\/)/;
class di {
  constructor(t) {
    this.context = t, this.ui = l.summernote.ui, this.$body = l(document.body), this.$editor = t.layoutInfo.editor, this.options = t.options, this.lang = this.options.langInfo, t.memo("help.linkDialog.show", this.options.langInfo.help["linkDialog.show"]);
  }
  initialize() {
    const t = this.options.dialogsInBody ? this.$body : this.options.container, e = [
      '<div class="form-group note-form-group">',
      `<label for="note-dialog-link-txt-${this.options.id}" class="note-form-label">${this.lang.link.textToDisplay}</label>`,
      `<input id="note-dialog-link-txt-${this.options.id}" class="note-link-text form-control note-form-control note-input" type="text"/>`,
      "</div>",
      '<div class="form-group note-form-group">',
      `<label for="note-dialog-link-url-${this.options.id}" class="note-form-label">${this.lang.link.url}</label>`,
      `<input id="note-dialog-link-url-${this.options.id}" class="note-link-url form-control note-form-control note-input" type="text" value="http://"/>`,
      "</div>",
      this.options.disableLinkTarget ? "" : l("<div></div>").append(this.ui.checkbox({
        className: "sn-checkbox-open-in-new-window",
        text: this.lang.link.openInNewWindow,
        checked: !0
      }).render()).html()
    ].join(""), n = `<input type="button" href="#" class="btn btn-primary note-btn note-btn-primary note-link-btn" value="${this.lang.link.insert}" disabled>`;
    this.$dialog = this.ui.dialog({
      className: "link-dialog",
      title: this.lang.link.insert,
      fade: this.options.dialogsFade,
      body: e,
      footer: n
    }).render().appendTo(t);
  }
  destroy() {
    this.ui.hideDialog(this.$dialog), this.$dialog.remove();
  }
  bindEnterKey(t, e) {
    t.on("keypress", (o) => {
      o.keyCode === x.code.ENTER && (o.preventDefault(), e.trigger("click"));
    });
  }
  checkLinkUrl(t) {
    return this.options.onCreateLink ? this.options.onCreateLink(t) : ai.test(t) ? "mailto:" + t : li.test(t) ? "tel:" + t : ci.test(t) ? t : "http://" + t;
  }
  onCheckLinkUrl(t) {
    t.on("blur", (e) => {
      e.target.value = e.target.value == "" ? "" : this.checkLinkUrl(e.target.value);
    });
  }
  /**
   * toggle update button
   */
  toggleLinkBtn(t, e, o) {
    this.ui.toggleBtn(t, e.val() && o.val());
  }
  /**
   * Show link dialog and set event handlers on dialog controls.
   *
   * @param {Object} linkInfo
   * @return {Promise}
   */
  showLinkDialog(t) {
    return l.Deferred((e) => {
      const o = this.$dialog.find(".note-link-text"), n = this.$dialog.find(".note-link-url"), s = this.$dialog.find(".note-link-btn"), a = this.$dialog.find(".sn-checkbox-open-in-new-window input[type=checkbox]");
      this.ui.onDialogShown(this.$dialog, () => {
        this.context.triggerEvent("dialog.shown"), !t.url && v.isValidUrl(t.text) && (t.url = this.checkLinkUrl(t.text)), o.on("input paste propertychange", () => {
          let d = o.val(), h = document.createElement("div");
          h.innerText = d, d = h.innerHTML, t.text = d, this.toggleLinkBtn(s, o, n);
        }).val(t.text), n.on("input paste propertychange", () => {
          t.text || o.val(n.val()), this.toggleLinkBtn(s, o, n);
        }).val(t.url), $.isSupportTouch || n.trigger("focus"), this.toggleLinkBtn(s, o, n), this.bindEnterKey(n, s), this.bindEnterKey(o, s), this.onCheckLinkUrl(n);
        const c = t.isNewWindow !== void 0 ? t.isNewWindow : this.context.options.linkTargetBlank;
        a.prop("checked", c), s.one("click", (d) => {
          d.preventDefault(), e.resolve({
            range: t.range,
            url: n.val(),
            text: o.val(),
            isNewWindow: a.is(":checked")
          }), this.ui.hideDialog(this.$dialog);
        });
      }), this.ui.onDialogHidden(this.$dialog, () => {
        o.off(), n.off(), s.off(), e.state() === "pending" && e.reject();
      }), this.ui.showDialog(this.$dialog);
    }).promise();
  }
  /**
   * @param {Object} layoutInfo
   */
  show() {
    const t = this.context.invoke("editor.getLinkInfo");
    this.context.invoke("editor.saveRange"), this.showLinkDialog(t).then((e) => {
      this.context.invoke("editor.restoreRange"), this.context.invoke("editor.createLink", e);
    }).fail(() => {
      this.context.invoke("editor.restoreRange");
    });
  }
}
class hi {
  constructor(t) {
    this.context = t, this.ui = l.summernote.ui, this.options = t.options, this.events = {
      "summernote.keyup summernote.mouseup summernote.change summernote.scroll": () => {
        this.update();
      },
      "summernote.disable summernote.dialog.shown": () => {
        this.hide();
      },
      "summernote.blur": (e, o) => {
        o.originalEvent && o.originalEvent.relatedTarget ? this.$popover[0].contains(o.originalEvent.relatedTarget) || this.hide() : this.hide();
      }
    };
  }
  shouldInitialize() {
    return !f.isEmpty(this.options.popover.link);
  }
  initialize() {
    this.$popover = this.ui.popover({
      className: "note-link-popover",
      callback: (e) => {
        e.find(".popover-content,.note-popover-content").prepend('<span><a target="_blank"></a>&nbsp;</span>');
      }
    }).render().appendTo(this.options.container);
    const t = this.$popover.find(".popover-content,.note-popover-content");
    this.context.invoke("buttons.build", t, this.options.popover.link), this.$popover.on("mousedown", (e) => {
      e.preventDefault();
    });
  }
  destroy() {
    this.$popover.remove();
  }
  update() {
    if (!this.context.invoke("editor.hasFocus")) {
      this.hide();
      return;
    }
    const t = this.context.invoke("editor.getLastRange");
    if (t.isCollapsed() && t.isOnAnchor()) {
      const e = r.ancestor(t.sc, r.isAnchor), o = l(e).attr("href");
      this.$popover.find("a").attr("href", o).text(o);
      const n = r.posFromPlaceholder(e), s = l(this.options.container).offset();
      n.top -= s.top, n.left -= s.left, this.$popover.css({
        display: "block",
        left: n.left,
        top: n.top
      });
    } else
      this.hide();
  }
  hide() {
    this.$popover.hide();
  }
}
class ui {
  constructor(t) {
    this.context = t, this.ui = l.summernote.ui, this.$body = l(document.body), this.$editor = t.layoutInfo.editor, this.options = t.options, this.lang = this.options.langInfo;
  }
  initialize() {
    let t = "";
    if (this.options.maximumImageFileSize) {
      const a = Math.floor(Math.log(this.options.maximumImageFileSize) / Math.log(1024)), c = (this.options.maximumImageFileSize / Math.pow(1024, a)).toFixed(2) * 1 + " " + " KMGTP"[a] + "B";
      t = `<small>${this.lang.image.maximumFileSize + " : " + c}</small>`;
    }
    const e = this.options.dialogsInBody ? this.$body : this.options.container, o = [
      '<div class="form-group note-form-group note-group-select-from-files">',
      '<label for="note-dialog-image-file-' + this.options.id + '" class="note-form-label">' + this.lang.image.selectFromFiles + "</label>",
      '<input id="note-dialog-image-file-' + this.options.id + '" class="note-image-input form-control-file note-form-control note-input" ',
      ' type="file" name="files" accept="' + this.options.acceptImageFileTypes + '" multiple="multiple"/>',
      t,
      "</div>",
      '<div class="form-group note-group-image-url">',
      '<label for="note-dialog-image-url-' + this.options.id + '" class="note-form-label">' + this.lang.image.url + "</label>",
      '<input id="note-dialog-image-url-' + this.options.id + '" class="note-image-url form-control note-form-control note-input" type="text"/>',
      "</div>"
    ].join(""), s = `<input type="button" href="#" class="btn btn-primary note-btn note-btn-primary note-image-btn" value="${this.lang.image.insert}" disabled>`;
    this.$dialog = this.ui.dialog({
      title: this.lang.image.insert,
      fade: this.options.dialogsFade,
      body: o,
      footer: s
    }).render().appendTo(e);
  }
  destroy() {
    this.ui.hideDialog(this.$dialog), this.$dialog.remove();
  }
  bindEnterKey(t, e) {
    t.on("keypress", (o) => {
      o.keyCode === x.code.ENTER && (o.preventDefault(), e.trigger("click"));
    });
  }
  show() {
    this.context.invoke("editor.saveRange"), this.showImageDialog().then((t) => {
      this.ui.hideDialog(this.$dialog), this.context.invoke("editor.restoreRange"), typeof t == "string" ? this.options.callbacks.onImageLinkInsert ? this.context.triggerEvent("image.link.insert", t) : this.context.invoke("editor.insertImage", t) : this.context.invoke("editor.insertImagesOrCallback", t);
    }).fail(() => {
      this.context.invoke("editor.restoreRange");
    });
  }
  /**
   * show image dialog
   *
   * @param {jQuery} $dialog
   * @return {Promise}
   */
  showImageDialog() {
    return l.Deferred((t) => {
      const e = this.$dialog.find(".note-image-input"), o = this.$dialog.find(".note-image-url"), n = this.$dialog.find(".note-image-btn");
      this.ui.onDialogShown(this.$dialog, () => {
        this.context.triggerEvent("dialog.shown"), e.replaceWith(e.clone().on("change", (s) => {
          t.resolve(s.target.files || s.target.value);
        }).val("")), o.on("input paste propertychange", () => {
          this.ui.toggleBtn(n, o.val());
        }).val(""), $.isSupportTouch || o.trigger("focus"), n.on("click", (s) => {
          s.preventDefault(), t.resolve(o.val());
        }), this.bindEnterKey(o, n);
      }), this.ui.onDialogHidden(this.$dialog, () => {
        e.off(), o.off(), n.off(), t.state() === "pending" && t.reject();
      }), this.ui.showDialog(this.$dialog);
    });
  }
}
class fi {
  constructor(t) {
    this.context = t, this.ui = l.summernote.ui, this.editable = t.layoutInfo.editable[0], this.options = t.options, this.events = {
      "summernote.disable summernote.dialog.shown": () => {
        this.hide();
      },
      "summernote.blur": (e, o) => {
        o.originalEvent && o.originalEvent.relatedTarget ? this.$popover[0].contains(o.originalEvent.relatedTarget) || this.hide() : this.hide();
      }
    };
  }
  shouldInitialize() {
    return !f.isEmpty(this.options.popover.image);
  }
  initialize() {
    this.$popover = this.ui.popover({
      className: "note-image-popover"
    }).render().appendTo(this.options.container);
    const t = this.$popover.find(".popover-content,.note-popover-content");
    this.context.invoke("buttons.build", t, this.options.popover.image), this.$popover.on("mousedown", (e) => {
      e.preventDefault();
    });
  }
  destroy() {
    this.$popover.remove();
  }
  update(t, e) {
    if (r.isImg(t)) {
      const o = l(t).offset(), n = l(this.options.container).offset();
      let s = {};
      this.options.popatmouse ? (s.left = e.pageX - 20, s.top = e.pageY) : s = o, s.top -= n.top, s.left -= n.left, this.$popover.css({
        display: "block",
        left: s.left,
        top: s.top
      });
    } else
      this.hide();
  }
  hide() {
    this.$popover.hide();
  }
}
class pi {
  constructor(t) {
    this.context = t, this.ui = l.summernote.ui, this.options = t.options, this.events = {
      "summernote.mousedown": (e, o) => {
        this.update(o.target);
      },
      "summernote.keyup summernote.scroll summernote.change": () => {
        this.update();
      },
      "summernote.disable summernote.dialog.shown": () => {
        this.hide();
      },
      "summernote.blur": (e, o) => {
        o.originalEvent && o.originalEvent.relatedTarget ? this.$popover[0].contains(o.originalEvent.relatedTarget) || this.hide() : this.hide();
      }
    };
  }
  shouldInitialize() {
    return !f.isEmpty(this.options.popover.table);
  }
  initialize() {
    this.$popover = this.ui.popover({
      className: "note-table-popover"
    }).render().appendTo(this.options.container);
    const t = this.$popover.find(".popover-content,.note-popover-content");
    this.context.invoke("buttons.build", t, this.options.popover.table), $.isFF && document.execCommand("enableInlineTableEditing", !1, !1), this.$popover.on("mousedown", (e) => {
      e.preventDefault();
    });
  }
  destroy() {
    this.$popover.remove();
  }
  update(t) {
    if (this.context.isDisabled())
      return !1;
    const e = r.isCell(t) || r.isCell(t == null ? void 0 : t.parentElement);
    if (e) {
      const o = r.posFromPlaceholder(t), n = l(this.options.container).offset();
      o.top -= n.top, o.left -= n.left, this.$popover.css({
        display: "block",
        left: o.left,
        top: o.top
      });
    } else
      this.hide();
    return e;
  }
  hide() {
    this.$popover.hide();
  }
}
class mi {
  constructor(t) {
    this.context = t, this.ui = l.summernote.ui, this.$body = l(document.body), this.$editor = t.layoutInfo.editor, this.options = t.options, this.lang = this.options.langInfo;
  }
  initialize() {
    const t = this.options.dialogsInBody ? this.$body : this.options.container, e = [
      '<div class="form-group note-form-group row-fluid">',
      `<label for="note-dialog-video-url-${this.options.id}" class="note-form-label">${this.lang.video.url} <small class="text-muted">${this.lang.video.providers}</small></label>`,
      `<input id="note-dialog-video-url-${this.options.id}" class="note-video-url form-control note-form-control note-input" type="text"/>`,
      "</div>"
    ].join(""), n = `<input type="button" href="#" class="btn btn-primary note-btn note-btn-primary note-video-btn" value="${this.lang.video.insert}" disabled>`;
    this.$dialog = this.ui.dialog({
      title: this.lang.video.insert,
      fade: this.options.dialogsFade,
      body: e,
      footer: n
    }).render().appendTo(t);
  }
  destroy() {
    this.ui.hideDialog(this.$dialog), this.$dialog.remove();
  }
  bindEnterKey(t, e) {
    t.on("keypress", (o) => {
      o.keyCode === x.code.ENTER && (o.preventDefault(), e.trigger("click"));
    });
  }
  createVideoNode(t) {
    const e = /(?:youtu\.be\/|youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=|shorts\/|live\/))([^&\n?]+)(?:.*[?&]t=([^&\n]+))?.*/, o = /^(?:(\d+)h)?(?:(\d+)m)?(?:(\d+)s)?$/, n = t.match(e), s = /(?:\.|\/\/)drive\.google\.com\/file\/d\/(.[a-zA-Z0-9_-]*)\/view/, a = t.match(s), c = /(?:www\.|\/\/)instagram\.com\/(reel|p)\/(.[a-zA-Z0-9_-]*)/, d = t.match(c), h = /\/\/vine\.co\/v\/([a-zA-Z0-9]+)/, u = t.match(h), p = /\/\/(player\.)?vimeo\.com\/([a-z]*\/)*(\d+)[?]?.*/, k = t.match(p), C = /.+dailymotion.com\/(video|hub)\/([^_]+)[^#]*(#video=([^_&]+))?/, N = t.match(C), L = /\/\/v\.youku\.com\/v_show\/id_(\w+)=*\.html/, G = t.match(L), m = /\/\/(.*)\/videos\/watch\/([^?]*)(?:\?(?:start=(\w*))?(?:&stop=(\w*))?(?:&loop=([10]))?(?:&autoplay=([10]))?(?:&muted=([10]))?)?/, g = t.match(m), y = /\/\/v\.qq\.com.*?vid=(.+)/, S = t.match(y), O = /\/\/v\.qq\.com\/x?\/?(page|cover).*?\/([^\/]+)\.html\??.*/, D = t.match(O), U = /^.+.(mp4|m4v)$/, H = t.match(U), P = /^.+.(ogg|ogv)$/, _ = t.match(P), ge = /^.+.(webm)$/, be = t.match(ge), ve = /(?:www\.|\/\/)facebook\.com\/([^\/]+)\/videos\/([0-9]+)/, ut = t.match(ve);
    let A;
    if (n && n[1].length === 11) {
      const pt = n[1];
      var X = 0;
      if (typeof n[2] < "u") {
        const mt = n[2].match(o);
        if (mt)
          for (var Lt = [3600, 60, 1], Q = 0, ke = Lt.length; Q < ke; Q++)
            X += typeof mt[Q + 1] < "u" ? Lt[Q] * parseInt(mt[Q + 1], 10) : 0;
        else
          X = parseInt(n[2], 10);
      }
      A = l("<iframe>").attr("frameborder", 0).attr("src", "//www.youtube.com/embed/" + pt + (X > 0 ? "?start=" + X : "")).attr("width", "640").attr("height", "360");
    } else if (a && a[0].length)
      A = l("<iframe>").attr("frameborder", 0).attr("src", "https://drive.google.com/file/d/" + a[1] + "/preview").attr("width", "640").attr("height", "480");
    else if (d && d[0].length)
      A = l("<iframe>").attr("frameborder", 0).attr("src", "https://instagram.com/p/" + d[2] + "/embed/").attr("width", "612").attr("height", "710").attr("scrolling", "no").attr("allowtransparency", "true");
    else if (u && u[0].length)
      A = l("<iframe>").attr("frameborder", 0).attr("src", u[0] + "/embed/simple").attr("width", "600").attr("height", "600").attr("class", "vine-embed");
    else if (k && k[3].length)
      A = l("<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>").attr("frameborder", 0).attr("src", "//player.vimeo.com/video/" + k[3]).attr("width", "640").attr("height", "360");
    else if (N && N[2].length)
      A = l("<iframe>").attr("frameborder", 0).attr("src", "//www.dailymotion.com/embed/video/" + N[2]).attr("width", "640").attr("height", "360");
    else if (G && G[1].length)
      A = l("<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>").attr("frameborder", 0).attr("height", "498").attr("width", "510").attr("src", "//player.youku.com/embed/" + G[1]);
    else if (g && g[0].length) {
      var ft = 0;
      g[2] !== "undefined" && (ft = g[2]);
      var Ft = 0;
      g[3] !== "undefined" && (Ft = g[3]);
      var Dt = 0;
      g[4] !== "undefined" && (Dt = g[4]);
      var Ht = 0;
      g[5] !== "undefined" && (Ht = g[5]);
      var Mt = 0;
      g[6] !== "undefined" && (Mt = g[6]), A = l('<iframe allowfullscreen sandbox="allow-same-origin allow-scripts allow-popups">').attr("frameborder", 0).attr("src", "//" + g[1] + "/videos/embed/" + g[2] + "?loop=" + Dt + "&autoplay=" + Ht + "&muted=" + Mt + (ft > 0 ? "&start=" + ft : "") + (Ft > 0 ? "&end=" + X : "")).attr("width", "560").attr("height", "315");
    } else if (S && S[1].length || D && D[2].length) {
      const pt = S && S[1].length ? S[1] : D[2];
      A = l("<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>").attr("frameborder", 0).attr("height", "310").attr("width", "500").attr("src", "https://v.qq.com/txp/iframe/player.html?vid=" + pt + "&amp;auto=0");
    } else if (H || _ || be)
      A = l("<video controls>").attr("src", t).attr("width", "640").attr("height", "360");
    else if (ut && ut[0].length)
      A = l("<iframe>").attr("frameborder", 0).attr("src", "https://www.facebook.com/plugins/video.php?href=" + encodeURIComponent(ut[0]) + "&show_text=0&width=560").attr("width", "560").attr("height", "301").attr("scrolling", "no").attr("allowtransparency", "true");
    else
      return !1;
    return A.addClass("note-video-clip"), A[0];
  }
  show() {
    const t = this.context.invoke("editor.getSelectedText");
    this.context.invoke("editor.saveRange"), this.showVideoDialog(t).then((e) => {
      this.ui.hideDialog(this.$dialog), this.context.invoke("editor.restoreRange");
      const o = this.createVideoNode(e);
      o && this.context.invoke("editor.insertNode", o);
    }).fail(() => {
      this.context.invoke("editor.restoreRange");
    });
  }
  /**
   * show video dialog
   *
   * @param {jQuery} $dialog
   * @return {Promise}
   */
  showVideoDialog() {
    return l.Deferred((t) => {
      const e = this.$dialog.find(".note-video-url"), o = this.$dialog.find(".note-video-btn");
      this.ui.onDialogShown(this.$dialog, () => {
        this.context.triggerEvent("dialog.shown"), e.on("input paste propertychange", () => {
          this.ui.toggleBtn(o, e.val());
        }), $.isSupportTouch || e.trigger("focus"), o.on("click", (n) => {
          n.preventDefault(), t.resolve(e.val());
        }), this.bindEnterKey(e, o);
      }), this.ui.onDialogHidden(this.$dialog, () => {
        e.off(), o.off(), t.state() === "pending" && t.reject();
      }), this.ui.showDialog(this.$dialog);
    });
  }
}
class gi {
  constructor(t) {
    this.context = t, this.ui = l.summernote.ui, this.$body = l(document.body), this.$editor = t.layoutInfo.editor, this.options = t.options, this.lang = this.options.langInfo;
  }
  initialize() {
    const t = this.options.dialogsInBody ? this.$body : this.options.container, e = [
      '<p class="text-center">',
      '<a href="http://summernote.org/" target="_blank" rel="noopener noreferrer">Summernote @@VERSION@@</a> Â· ',
      '<a href="https://github.com/summernote/summernote" target="_blank" rel="noopener noreferrer">Project</a> Â· ',
      '<a href="https://github.com/summernote/summernote/issues" target="_blank" rel="noopener noreferrer">Issues</a>',
      "</p>"
    ].join("");
    this.$dialog = this.ui.dialog({
      title: this.lang.options.help,
      fade: this.options.dialogsFade,
      body: this.createShortcutList(),
      footer: e,
      callback: (o) => {
        o.find(".modal-body,.note-modal-body").css({
          "max-height": 300,
          overflow: "scroll"
        });
      }
    }).render().appendTo(t);
  }
  destroy() {
    this.ui.hideDialog(this.$dialog), this.$dialog.remove();
  }
  createShortcutList() {
    const t = this.options.keyMap[$.isMac ? "mac" : "pc"];
    return Object.keys(t).map((e) => {
      const o = t[e], n = l('<div><div class="help-list-item"></div></div>');
      return n.append(l("<label><kbd>" + e + "</kdb></label>").css({
        width: 180,
        "margin-right": 10
      })).append(l("<span></span>").html(this.context.memo("help." + o) || o)), n.html();
    }).join("");
  }
  /**
   * show help dialog
   *
   * @return {Promise}
   */
  showHelpDialog() {
    return l.Deferred((t) => {
      this.ui.onDialogShown(this.$dialog, () => {
        this.context.triggerEvent("dialog.shown"), t.resolve();
      }), this.ui.showDialog(this.$dialog);
    }).promise();
  }
  show() {
    this.context.invoke("editor.saveRange"), this.showHelpDialog().then(() => {
      this.context.invoke("editor.restoreRange");
    });
  }
}
const bi = -5, vi = 5;
class ki {
  constructor(t) {
    this.context = t, this.ui = l.summernote.ui, this.options = t.options, this.hidable = !0, this.onContextmenu = !1, this.pageX = null, this.pageY = null, this.events = {
      "summernote.contextmenu": (e) => {
        this.options.editing && (e.preventDefault(), e.stopPropagation(), this.onContextmenu = !0, this.update(!0));
      },
      "summernote.mousedown": (e, o) => {
        this.pageX = o.pageX, this.pageY = o.pageY;
      },
      "summernote.keyup summernote.mouseup summernote.scroll": (e, o) => {
        if (this.options.editing && !this.onContextmenu) {
          if (o.type == "keyup") {
            let s = this.context.invoke("editor.getLastRange").getWordRange();
            const a = v.rect2bnd(f.last(s.getClientRects()));
            this.pageX = a.left, this.pageY = a.top;
          } else
            this.pageX = o.pageX, this.pageY = o.pageY;
          this.update();
        }
        this.onContextmenu = !1;
      },
      "summernote.disable summernote.change summernote.dialog.shown summernote.blur": () => {
        this.hide();
      },
      "summernote.focusout": () => {
        this.$popover.is(":active,:focus") || this.hide();
      }
    };
  }
  shouldInitialize() {
    return this.options.airMode && !f.isEmpty(this.options.popover.air);
  }
  initialize() {
    this.$popover = this.ui.popover({
      className: "note-air-popover"
    }).render().appendTo(this.options.container);
    const t = this.$popover.find(".popover-content,.note-popover-content");
    this.context.invoke("buttons.build", t, this.options.popover.air), this.$popover.on("mousedown", () => {
      this.hidable = !1;
    }), this.$popover.on("mouseup", () => {
      this.hidable = !0;
    });
  }
  destroy() {
    this.$popover.remove();
  }
  update(t) {
    const e = this.context.invoke("editor.currentStyle");
    if (e.range && (!e.range.isCollapsed() || t)) {
      let o = {
        left: this.pageX,
        top: this.pageY
      };
      const n = l(this.options.container).offset();
      o.top -= n.top, o.left -= n.left, this.$popover.css({
        display: "block",
        left: Math.max(o.left, 0) + bi,
        top: o.top + vi
      }), this.context.invoke("buttons.updateCurrentStyle", this.$popover);
    } else
      this.hide();
  }
  updateCodeview(t) {
    this.ui.toggleBtnActive(this.$popover.find(".btn-codeview"), t), t && this.hide();
  }
  hide() {
    this.hidable && this.$popover.hide();
  }
}
const Wt = 5;
class Ci {
  constructor(t) {
    this.context = t, this.ui = l.summernote.ui, this.$editable = t.layoutInfo.editable, this.options = t.options, this.hint = this.options.hint || [], this.direction = this.options.hintDirection || "bottom", this.hints = Array.isArray(this.hint) ? this.hint : [this.hint], this.events = {
      "summernote.keyup": (e, o) => {
        o.isDefaultPrevented() || this.handleKeyup(o);
      },
      "summernote.keydown": (e, o) => {
        this.handleKeydown(o);
      },
      "summernote.disable summernote.dialog.shown summernote.blur": () => {
        this.hide();
      }
    };
  }
  shouldInitialize() {
    return this.hints.length > 0;
  }
  initialize() {
    this.lastWordRange = null, this.matchingWord = null, this.$popover = this.ui.popover({
      className: "note-hint-popover",
      hideArrow: !0,
      direction: ""
    }).render().appendTo(this.options.container), this.$popover.hide(), this.$content = this.$popover.find(".popover-content,.note-popover-content"), this.$content.on("click", ".note-hint-item", (t) => {
      this.$content.find(".active").removeClass("active"), l(t.currentTarget).addClass("active"), this.replace();
    }), this.$popover.on("mousedown", (t) => {
      t.preventDefault();
    });
  }
  destroy() {
    this.$popover.remove();
  }
  selectItem(t) {
    this.$content.find(".active").removeClass("active"), t.addClass("active"), this.$content[0].scrollTop = t[0].offsetTop - this.$content.innerHeight() / 2;
  }
  moveDown() {
    const t = this.$content.find(".note-hint-item.active"), e = t.next();
    if (e.length)
      this.selectItem(e);
    else {
      let o = t.parent().next();
      o.length || (o = this.$content.find(".note-hint-group").first()), this.selectItem(o.find(".note-hint-item").first());
    }
  }
  moveUp() {
    const t = this.$content.find(".note-hint-item.active"), e = t.prev();
    if (e.length)
      this.selectItem(e);
    else {
      let o = t.parent().prev();
      o.length || (o = this.$content.find(".note-hint-group").last()), this.selectItem(o.find(".note-hint-item").last());
    }
  }
  replace() {
    const t = this.$content.find(".note-hint-item.active");
    if (t.length) {
      var e = this.nodeFromItem(t);
      if (this.matchingWord !== null && this.matchingWord.length === 0)
        this.lastWordRange.so = this.lastWordRange.eo;
      else if (this.matchingWord !== null && this.matchingWord.length > 0 && !this.lastWordRange.isCollapsed()) {
        let n = this.lastWordRange.eo - this.lastWordRange.so - this.matchingWord.length;
        n > 0 && (this.lastWordRange.so += n);
      }
      if (this.lastWordRange.insertNode(e), this.options.hintSelect === "next") {
        var o = document.createTextNode("");
        l(e).after(o), w.createFromNodeBefore(o).select();
      } else
        w.createFromNodeAfter(e).select();
      this.lastWordRange = null, this.hide(), this.context.invoke("editor.focus"), this.context.triggerEvent("change", this.$editable.html(), this.$editable);
    }
  }
  nodeFromItem(t) {
    const e = this.hints[t.data("index")], o = t.data("item");
    let n = e.content ? e.content(o) : o;
    return typeof n == "string" && (n = r.createText(n)), n;
  }
  createItemTemplates(t, e) {
    const o = this.hints[t];
    return e.map((n, s) => {
      const a = l('<div class="note-hint-item"></div>');
      return a.append(o.template ? o.template(n) : n + ""), a.data({
        index: t,
        item: n
      }), t === 0 && s === 0 && a.addClass("active"), a;
    });
  }
  handleKeydown(t) {
    this.$popover.is(":visible") && (t.keyCode === x.code.ENTER ? (t.preventDefault(), this.replace()) : t.keyCode === x.code.UP ? (t.preventDefault(), this.moveUp()) : t.keyCode === x.code.DOWN && (t.preventDefault(), this.moveDown()));
  }
  searchKeyword(t, e, o) {
    const n = this.hints[t];
    if (n && n.match.test(e) && n.search) {
      const s = n.match.exec(e);
      this.matchingWord = s[0], n.search(s[1], o);
    } else
      o();
  }
  createGroup(t, e) {
    const o = l('<div class="note-hint-group note-hint-group-' + t + '"></div>');
    return this.searchKeyword(t, e, (n) => {
      n = n || [], n.length && (o.html(this.createItemTemplates(t, n)), this.show());
    }), o;
  }
  handleKeyup(t) {
    if (!f.contains([x.code.ENTER, x.code.UP, x.code.DOWN], t.keyCode)) {
      let e = this.context.invoke("editor.getLastRange"), o, n;
      if (this.options.hintMode === "words") {
        if (o = e.getWordsRange(e), n = o.toString(), this.hints.forEach((s) => {
          if (s.match.test(n))
            return o = e.getWordsMatchRange(s.match), !1;
        }), !o) {
          this.hide();
          return;
        }
        n = o.toString();
      } else
        o = e.getWordRange(), n = o.toString();
      if (this.hints.length && n) {
        this.$content.empty();
        const s = v.rect2bnd(f.last(o.getClientRects())), a = l(this.options.container).offset();
        s && (s.top -= a.top, s.left -= a.left, this.$popover.hide(), this.lastWordRange = o, this.hints.forEach((c, d) => {
          c.match.test(n) && this.createGroup(d, n).appendTo(this.$content);
        }), this.$content.find(".note-hint-item").first().addClass("active"), this.direction === "top" ? this.$popover.css({
          left: s.left,
          top: s.top - this.$popover.outerHeight() - Wt
        }) : this.$popover.css({
          left: s.left,
          top: s.top + s.height + Wt
        }));
      } else
        this.hide();
    }
  }
  show() {
    this.$popover.show();
  }
  hide() {
    this.$popover.hide();
  }
}
l.summernote = l.extend(l.summernote, {
  version: "@@VERSION@@",
  plugins: {},
  dom: r,
  range: w,
  lists: f,
  options: {
    langInfo: l.summernote.lang["en-US"],
    editing: !0,
    modules: {
      editor: _o,
      clipboard: qo,
      dropzone: Go,
      codeview: Yo,
      statusbar: Zo,
      fullscreen: Xo,
      handle: Qo,
      // FIXME: HintPopover must be front of autolink
      //  - Script error about range when Enter key is pressed on hint popover
      hintPopover: Ci,
      autoLink: ei,
      autoSync: oi,
      autoReplace: ii,
      placeholder: ni,
      buttons: si,
      toolbar: ri,
      linkDialog: di,
      linkPopover: hi,
      imageDialog: ui,
      imagePopover: fi,
      tablePopover: pi,
      videoDialog: mi,
      helpDialog: gi,
      airPopover: ki
    },
    buttons: {},
    lang: "en-US",
    followingToolbar: !1,
    toolbarPosition: "top",
    otherStaticBar: "",
    // toolbar
    codeviewKeepButton: !1,
    toolbar: [
      ["style", ["style"]],
      ["font", ["bold", "underline", "clear"]],
      ["fontname", ["fontname"]],
      ["color", ["color"]],
      ["para", ["ul", "ol", "paragraph"]],
      ["table", ["table"]],
      ["insert", ["link", "picture", "video"]],
      ["view", ["fullscreen", "codeview", "help"]]
    ],
    // popover
    popatmouse: !0,
    popover: {
      image: [
        ["resize", ["resizeFull", "resizeHalf", "resizeQuarter", "resizeNone"]],
        ["float", ["floatLeft", "floatRight", "floatNone"]],
        ["remove", ["removeMedia"]]
      ],
      link: [
        ["link", ["linkDialogShow", "unlink"]]
      ],
      table: [
        ["add", ["addRowDown", "addRowUp", "addColLeft", "addColRight"]],
        ["delete", ["deleteRow", "deleteCol", "deleteTable"]]
      ],
      air: [
        ["color", ["color"]],
        ["font", ["bold", "underline", "clear"]],
        ["para", ["ul", "paragraph"]],
        ["table", ["table"]],
        ["insert", ["link", "picture"]],
        ["view", ["fullscreen", "codeview"]]
      ]
    },
    // link options
    linkAddNoReferrer: !1,
    addLinkNoOpener: !1,
    // air mode: inline editor
    airMode: !1,
    overrideContextMenu: !1,
    // TBD
    width: null,
    height: null,
    linkTargetBlank: !0,
    focus: !1,
    tabDisable: !1,
    tabSize: 4,
    styleWithCSS: !1,
    shortcuts: !0,
    textareaAutoSync: !0,
    tooltip: "auto",
    container: null,
    maxTextLength: 0,
    blockquoteBreakingLevel: 2,
    spellCheck: !0,
    disableGrammar: !1,
    placeholder: null,
    inheritPlaceholder: !1,
    // TODO: need to be documented
    recordEveryKeystroke: !1,
    historyLimit: 200,
    // TODO: need to be documented
    showDomainOnlyForAutolink: !1,
    // TODO: need to be documented
    hintMode: "word",
    hintSelect: "after",
    hintDirection: "bottom",
    styleTags: ["p", "blockquote", "pre", "h1", "h2", "h3", "h4", "h5", "h6"],
    fontNames: [
      "Arial",
      "Arial Black",
      "Comic Sans MS",
      "Courier New",
      "Helvetica Neue",
      "Helvetica",
      "Impact",
      "Lucida Grande",
      "Tahoma",
      "Times New Roman",
      "Verdana"
    ],
    fontNamesIgnoreCheck: [],
    addDefaultFonts: !0,
    fontSizes: ["8", "9", "10", "11", "12", "14", "18", "24", "36"],
    fontSizeUnits: ["px", "pt"],
    // pallete colors(n x n)
    colors: [
      ["#000000", "#424242", "#636363", "#9C9C94", "#CEC6CE", "#EFEFEF", "#F7F7F7", "#FFFFFF"],
      ["#FF0000", "#FF9C00", "#FFFF00", "#00FF00", "#00FFFF", "#0000FF", "#9C00FF", "#FF00FF"],
      ["#F7C6CE", "#FFE7CE", "#FFEFC6", "#D6EFD6", "#CEDEE7", "#CEE7F7", "#D6D6E7", "#E7D6DE"],
      ["#E79C9C", "#FFC69C", "#FFE79C", "#B5D6A5", "#A5C6CE", "#9CC6EF", "#B5A5D6", "#D6A5BD"],
      ["#E76363", "#F7AD6B", "#FFD663", "#94BD7B", "#73A5AD", "#6BADDE", "#8C7BC6", "#C67BA5"],
      ["#CE0000", "#E79439", "#EFC631", "#6BA54A", "#4A7B8C", "#3984C6", "#634AA5", "#A54A7B"],
      ["#9C0000", "#B56308", "#BD9400", "#397B21", "#104A5A", "#085294", "#311873", "#731842"],
      ["#630000", "#7B3900", "#846300", "#295218", "#083139", "#003163", "#21104A", "#4A1031"]
    ],
    // http://chir.ag/projects/name-that-color/
    colorsName: [
      ["Black", "Tundora", "Dove Gray", "Star Dust", "Pale Slate", "Gallery", "Alabaster", "White"],
      ["Red", "Orange Peel", "Yellow", "Green", "Cyan", "Blue", "Electric Violet", "Magenta"],
      ["Azalea", "Karry", "Egg White", "Zanah", "Botticelli", "Tropical Blue", "Mischka", "Twilight"],
      ["Tonys Pink", "Peach Orange", "Cream Brulee", "Sprout", "Casper", "Perano", "Cold Purple", "Careys Pink"],
      ["Mandy", "Rajah", "Dandelion", "Olivine", "Gulf Stream", "Viking", "Blue Marguerite", "Puce"],
      ["Guardsman Red", "Fire Bush", "Golden Dream", "Chelsea Cucumber", "Smalt Blue", "Boston Blue", "Butterfly Bush", "Cadillac"],
      ["Sangria", "Mai Tai", "Buddha Gold", "Forest Green", "Eden", "Venice Blue", "Meteorite", "Claret"],
      ["Rosewood", "Cinnamon", "Olive", "Parsley", "Tiber", "Midnight Blue", "Valentino", "Loulou"]
    ],
    colorButton: {
      foreColor: "#000000",
      backColor: "#FFFF00"
    },
    lineHeights: ["1.0", "1.2", "1.4", "1.5", "1.6", "1.8", "2.0", "3.0"],
    tableClassName: "table table-bordered",
    insertTableMaxSize: {
      col: 10,
      row: 10
    },
    // By default, dialogs are attached in container.
    dialogsInBody: !1,
    dialogsFade: !1,
    maximumImageFileSize: null,
    acceptImageFileTypes: "image/*",
    allowClipboardImagePasting: !0,
    callbacks: {
      onBeforeCommand: null,
      onBlur: null,
      onBlurCodeview: null,
      onChange: null,
      onChangeCodeview: null,
      onDialogShown: null,
      onEnter: null,
      onFocus: null,
      onImageLinkInsert: null,
      onImageUpload: null,
      onImageUploadError: null,
      onInit: null,
      onKeydown: null,
      onKeyup: null,
      onMousedown: null,
      onMouseup: null,
      onPaste: null,
      onScroll: null
    },
    codemirror: {
      mode: "text/html",
      htmlMode: !0,
      lineNumbers: !0
    },
    codeviewFilter: !0,
    codeviewFilterRegex: /<\/*(?:applet|b(?:ase|gsound|link)|embed|frame(?:set)?|ilayer|l(?:ayer|ink)|meta|object|s(?:cript|tyle)|t(?:itle|extarea)|xml)[^>]*?>/gi,
    codeviewIframeFilter: !0,
    codeviewIframeWhitelistSrc: [],
    codeviewIframeWhitelistSrcBase: [
      "www.youtube.com",
      "www.youtube-nocookie.com",
      "www.facebook.com",
      "vine.co",
      "instagram.com",
      "player.vimeo.com",
      "www.dailymotion.com",
      "player.youku.com",
      "jumpingbean.tv",
      "v.qq.com"
    ],
    keyMap: {
      pc: {
        ESC: "escape",
        ENTER: "insertParagraph",
        "CTRL+Z": "undo",
        "CTRL+Y": "redo",
        TAB: "tab",
        "SHIFT+TAB": "untab",
        "CTRL+B": "bold",
        "CTRL+I": "italic",
        "CTRL+U": "underline",
        "CTRL+SHIFT+S": "strikethrough",
        "CTRL+BACKSLASH": "removeFormat",
        "CTRL+SHIFT+L": "justifyLeft",
        "CTRL+SHIFT+E": "justifyCenter",
        "CTRL+SHIFT+R": "justifyRight",
        "CTRL+SHIFT+J": "justifyFull",
        "CTRL+SHIFT+NUM7": "insertUnorderedList",
        "CTRL+SHIFT+NUM8": "insertOrderedList",
        "CTRL+LEFTBRACKET": "outdent",
        "CTRL+RIGHTBRACKET": "indent",
        "CTRL+NUM0": "formatPara",
        "CTRL+NUM1": "formatH1",
        "CTRL+NUM2": "formatH2",
        "CTRL+NUM3": "formatH3",
        "CTRL+NUM4": "formatH4",
        "CTRL+NUM5": "formatH5",
        "CTRL+NUM6": "formatH6",
        "CTRL+ENTER": "insertHorizontalRule",
        "CTRL+K": "linkDialog.show"
      },
      mac: {
        ESC: "escape",
        ENTER: "insertParagraph",
        "CMD+Z": "undo",
        "CMD+SHIFT+Z": "redo",
        TAB: "tab",
        "SHIFT+TAB": "untab",
        "CMD+B": "bold",
        "CMD+I": "italic",
        "CMD+U": "underline",
        "CMD+SHIFT+S": "strikethrough",
        "CMD+BACKSLASH": "removeFormat",
        "CMD+SHIFT+L": "justifyLeft",
        "CMD+SHIFT+E": "justifyCenter",
        "CMD+SHIFT+R": "justifyRight",
        "CMD+SHIFT+J": "justifyFull",
        "CMD+SHIFT+NUM7": "insertUnorderedList",
        "CMD+SHIFT+NUM8": "insertOrderedList",
        "CMD+LEFTBRACKET": "outdent",
        "CMD+RIGHTBRACKET": "indent",
        "CMD+NUM0": "formatPara",
        "CMD+NUM1": "formatH1",
        "CMD+NUM2": "formatH2",
        "CMD+NUM3": "formatH3",
        "CMD+NUM4": "formatH4",
        "CMD+NUM5": "formatH5",
        "CMD+NUM6": "formatH6",
        "CMD+ENTER": "insertHorizontalRule",
        "CMD+K": "linkDialog.show"
      }
    },
    icons: {
      align: "note-icon-align",
      alignCenter: "note-icon-align-center",
      alignJustify: "note-icon-align-justify",
      alignLeft: "note-icon-align-left",
      alignRight: "note-icon-align-right",
      rowBelow: "note-icon-row-below",
      colBefore: "note-icon-col-before",
      colAfter: "note-icon-col-after",
      rowAbove: "note-icon-row-above",
      rowRemove: "note-icon-row-remove",
      colRemove: "note-icon-col-remove",
      indent: "note-icon-align-indent",
      outdent: "note-icon-align-outdent",
      arrowsAlt: "note-icon-arrows-alt",
      bold: "note-icon-bold",
      caret: "note-icon-caret",
      circle: "note-icon-circle",
      close: "note-icon-close",
      code: "note-icon-code",
      eraser: "note-icon-eraser",
      floatLeft: "note-icon-float-left",
      floatRight: "note-icon-float-right",
      font: "note-icon-font",
      frame: "note-icon-frame",
      italic: "note-icon-italic",
      link: "note-icon-link",
      unlink: "note-icon-chain-broken",
      magic: "note-icon-magic",
      menuCheck: "note-icon-menu-check",
      minus: "note-icon-minus",
      orderedlist: "note-icon-orderedlist",
      pencil: "note-icon-pencil",
      picture: "note-icon-picture",
      question: "note-icon-question",
      redo: "note-icon-redo",
      rollback: "note-icon-rollback",
      square: "note-icon-square",
      strikethrough: "note-icon-strikethrough",
      subscript: "note-icon-subscript",
      superscript: "note-icon-superscript",
      table: "note-icon-table",
      textHeight: "note-icon-text-height",
      trash: "note-icon-trash",
      underline: "note-icon-underline",
      undo: "note-icon-undo",
      unorderedlist: "note-icon-unorderedlist",
      video: "note-icon-video"
    }
  }
});
class wi {
  constructor(t, e, o, n) {
    this.markup = t, this.children = e, this.options = o, this.callback = n;
  }
  render(t) {
    const e = l(this.markup);
    if (this.options && this.options.contents && e.html(this.options.contents), this.options && this.options.className && e.addClass(this.options.className), this.options && this.options.data && l.each(this.options.data, (o, n) => {
      e.attr("data-" + o, n);
    }), this.options && this.options.click && e.on("click", this.options.click), this.children) {
      const o = e.find(".note-children-container");
      this.children.forEach((n) => {
        n.render(o.length ? o : e);
      });
    }
    return this.callback && this.callback(e, this.options), this.options && this.options.callback && this.options.callback(e), t && t.append(e), e;
  }
}
const I = {
  create: (i, t) => function() {
    const e = typeof arguments[1] == "object" ? arguments[1] : arguments[0];
    let o = Array.isArray(arguments[0]) ? arguments[0] : [];
    return e && e.children && (o = e.children), new wi(i, o, e, t);
  }
};
class fe {
  constructor(t, e) {
    if (this.$node = t, this.options = l.extend({}, {
      title: "",
      target: e.container,
      trigger: "hover focus",
      placement: "bottom"
    }, e), this.$tooltip = l([
      '<div class="note-tooltip">',
      '<div class="note-tooltip-arrow"></div>',
      '<div class="note-tooltip-content"></div>',
      "</div>"
    ].join("")), this.options.trigger !== "manual") {
      const o = this.show.bind(this), n = this.hide.bind(this), s = this.toggle.bind(this);
      this.options.trigger.split(" ").forEach(function(a) {
        a === "hover" ? (t.off("mouseenter mouseleave"), t.on("mouseenter", o).on("mouseleave", n)) : a === "click" ? t.on("click", s) : a === "focus" && t.on("focus", o).on("blur", n);
      });
    }
  }
  show() {
    const t = this.$node, e = t.offset(), o = l(this.options.target).offset();
    e.top -= o.top, e.left -= o.left;
    const n = this.$tooltip, s = this.options.title || t.attr("title") || t.data("title"), a = this.options.placement || t.data("placement");
    n.addClass(a), n.find(".note-tooltip-content").text(s), n.appendTo(this.options.target);
    const c = t.outerWidth(), d = t.outerHeight(), h = n.outerWidth(), u = n.outerHeight();
    a === "bottom" ? n.css({
      top: e.top + d,
      left: e.left + (c / 2 - h / 2)
    }) : a === "top" ? n.css({
      top: e.top - u,
      left: e.left + (c / 2 - h / 2)
    }) : a === "left" ? n.css({
      top: e.top + (d / 2 - u / 2),
      left: e.left - h
    }) : a === "right" && n.css({
      top: e.top + (d / 2 - u / 2),
      left: e.left + c
    }), n.addClass("in");
  }
  hide() {
    this.$tooltip.removeClass("in"), setTimeout(() => {
      this.$tooltip.remove();
    }, 200);
  }
  toggle() {
    this.$tooltip.hasClass("in") ? this.hide() : this.show();
  }
}
class xi {
  constructor(t, e) {
    this.$button = t, this.options = l.extend({}, {
      target: e.container
    }, e), this.setEvent();
  }
  setEvent() {
    this.$button.on("click", (t) => {
      this.toggle(), t.stopImmediatePropagation();
    });
  }
  clear() {
    var t = l(".note-btn-group.open");
    t.find(".note-btn.active").removeClass("active"), t.removeClass("open");
  }
  show() {
    this.$button.addClass("active"), this.$button.parent().addClass("open");
    var t = this.$button.next(), e = t.offset(), o = t.outerWidth(), n = l(window).width(), s = parseFloat(l(this.options.target).css("margin-right"));
    e.left + o > n - s ? t.css("margin-left", n - s - (e.left + o)) : t.css("margin-left", "");
  }
  hide() {
    this.$button.removeClass("active"), this.$button.parent().removeClass("open");
  }
  toggle() {
    var t = this.$button.parent().hasClass("open");
    this.clear(), t ? this.hide() : this.show();
  }
}
l(document).on("click.note-dropdown-menu", function(i) {
  l(i.target).closest(".note-btn-group").length || (l(".note-btn-group.open .note-btn.active").removeClass("active"), l(".note-btn-group.open").removeClass("open"));
});
l(document).on("click.note-dropdown-menu", function(i) {
  l(i.target).closest(".note-dropdown-menu").parent().removeClass("open"), l(i.target).closest(".note-dropdown-menu").parent().find(".note-btn.active").removeClass("active");
});
class yi {
  constructor(t) {
    this.$modal = t, this.$backdrop = l('<div class="note-modal-backdrop"></div>');
  }
  show() {
    this.$backdrop.appendTo(document.body).show(), this.$modal.addClass("open").show(), this.$modal.trigger("note.modal.show"), this.$modal.off("click", ".close").on("click", ".close", this.hide.bind(this)), this.$modal.on("keydown", (t) => {
      t.which === 27 && (t.preventDefault(), this.hide());
    });
  }
  hide() {
    this.$modal.removeClass("open").hide(), this.$backdrop.hide(), this.$modal.trigger("note.modal.hide"), this.$modal.off("keydown");
  }
}
const bt = I.create('<div class="note-editor note-frame"></div>'), vt = I.create('<div class="note-toolbar" role="toolbar"></div>'), nt = I.create('<div class="note-editing-area"></div>'), st = I.create('<textarea class="note-codable" aria-multiline="true"></textarea>'), kt = I.create(
  '<div class="note-editable" contentEditable="true" role="textbox" aria-multiline="true"></div>'
), Ct = I.create(
  [
    '<output class="note-status-output" role="status" aria-live="polite"></output>',
    '<div class="note-statusbar" role="status">',
    '<div class="note-resizebar" aria-label="resize">',
    '<div class="note-icon-bar"></div>',
    '<div class="note-icon-bar"></div>',
    '<div class="note-icon-bar"></div>',
    "</div>",
    "</div>"
  ].join("")
), Kt = I.create('<div class="note-editor note-airframe"></div>'), Vt = I.create(
  [
    '<div class="note-editable" contentEditable="true" role="textbox" aria-multiline="true"></div>',
    '<output class="note-status-output" role="status" aria-live="polite"></output>'
  ].join("")
), W = I.create('<div class="note-btn-group"></div>'), q = I.create(
  '<button type="button" class="note-btn" tabindex="-1"></button>',
  function(i, t) {
    if (t && t.tooltip) {
      const e = t.container;
      i.attr({
        "aria-label": t.tooltip
      }), e && l(e).length ? i.data(
        "_lite_tooltip",
        new fe(i, {
          title: t.tooltip,
          container: e
        })
      ).on("click", (o) => {
        l(o.currentTarget).data("_lite_tooltip").hide();
      }) : console.warn("Summernote: Tooltip container not found, please set the container property for the Summernote Config, skipping tooltip initialization");
    }
    t.contents && i.html(t.contents), t && t.data && t.data.toggle === "dropdown" && i.data(
      "_lite_dropdown",
      new xi(i, {
        container: t.container
      })
    ), t && t.codeviewKeepButton && i.addClass("note-codeview-keep");
  }
), it = I.create('<div class="note-dropdown-menu" role="list"></div>', function(i, t) {
  const e = Array.isArray(t.items) ? t.items.map(function(o) {
    const n = typeof o == "string" ? o : o.value || "", s = t.template ? t.template(o) : o, a = l(
      '<a class="note-dropdown-item" href="#" data-value="' + n + '" role="listitem" aria-label="' + n + '"></a>'
    );
    return a.html(s).data("item", o), a;
  }) : t.items;
  i.html(e).attr({ "aria-label": t.title }), i.on("click", "> .note-dropdown-item", function(o) {
    const n = l(this), s = n.data("item"), a = n.data("value");
    s.click ? s.click(n) : t.itemClick && t.itemClick(o, s, a);
  }), t && t.codeviewKeepButton && i.addClass("note-codeview-keep");
}), pe = I.create(
  '<div class="note-dropdown-menu note-check" role="list"></div>',
  function(i, t) {
    const e = Array.isArray(t.items) ? t.items.map(function(o) {
      const n = typeof o == "string" ? o : o.value || "", s = t.template ? t.template(o) : o, a = l(
        '<a class="note-dropdown-item" href="#" data-value="' + n + '" role="listitem" aria-label="' + o + '"></a>'
      );
      return a.html([V(t.checkClassName), " ", s]).data("item", o), a;
    }) : t.items;
    i.html(e).attr({ "aria-label": t.title }), i.on("click", "> .note-dropdown-item", function(o) {
      const n = l(this), s = n.data("item"), a = n.data("value");
      s.click ? s.click(n) : t.itemClick && t.itemClick(o, s, a);
    }), t && t.codeviewKeepButton && i.addClass("note-codeview-keep");
  }
), Si = function(i, t) {
  return i + " " + V(t.icons.caret, "span");
}, $i = function(i, t) {
  return W(
    [
      q({
        className: "dropdown-toggle",
        contents: i.title + " " + V("note-icon-caret"),
        tooltip: i.tooltip,
        data: {
          toggle: "dropdown"
        }
      }),
      it({
        className: i.className,
        items: i.items,
        template: i.template,
        itemClick: i.itemClick
      })
    ],
    { callback: t }
  ).render();
}, Ti = function(i, t) {
  return W(
    [
      q({
        className: "dropdown-toggle",
        contents: i.title + " " + V("note-icon-caret"),
        tooltip: i.tooltip,
        data: {
          toggle: "dropdown"
        }
      }),
      pe({
        className: i.className,
        checkClassName: i.checkClassName,
        items: i.items,
        template: i.template,
        itemClick: i.itemClick
      })
    ],
    { callback: t }
  ).render();
}, Ei = function(i) {
  return W([
    q({
      className: "dropdown-toggle",
      contents: i.title + " " + V("note-icon-caret"),
      tooltip: i.tooltip,
      data: {
        toggle: "dropdown"
      }
    }),
    it([
      W({
        className: "note-align",
        children: i.items[0]
      }),
      W({
        className: "note-list",
        children: i.items[1]
      })
    ])
  ]).render();
}, Ni = function(i, t, e) {
  const n = l(i.target.parentNode), s = n.next(), a = n.find(".note-dimension-picker-mousecatcher"), c = n.find(".note-dimension-picker-highlighted"), d = n.find(".note-dimension-picker-unhighlighted");
  let h;
  if (i.offsetX === void 0) {
    const p = l(i.target).offset();
    h = {
      x: i.pageX - p.left,
      y: i.pageY - p.top
    };
  } else
    h = {
      x: i.offsetX,
      y: i.offsetY
    };
  const u = {
    c: Math.ceil(h.x / 18) || 1,
    r: Math.ceil(h.y / 18) || 1
  };
  c.css({ width: u.c + "em", height: u.r + "em" }), a.data("value", u.c + "x" + u.r), u.c > 3 && u.c < t && d.css({ width: u.c + 1 + "em" }), u.r > 3 && u.r < e && d.css({ height: u.r + 1 + "em" }), s.html(u.c + " x " + u.r);
}, Ri = function(i) {
  return W(
    [
      q({
        className: "dropdown-toggle",
        contents: i.title + " " + V("note-icon-caret"),
        tooltip: i.tooltip,
        data: {
          toggle: "dropdown"
        }
      }),
      it({
        className: "note-table",
        items: [
          '<div class="note-dimension-picker">',
          '<div class="note-dimension-picker-mousecatcher" data-event="insertTable" data-value="1x1"></div>',
          '<div class="note-dimension-picker-highlighted"></div>',
          '<div class="note-dimension-picker-unhighlighted"></div>',
          "</div>",
          '<div class="note-dimension-display">1 x 1</div>'
        ].join("")
      })
    ],
    {
      callback: function(t) {
        t.find(".note-dimension-picker-mousecatcher").css({
          width: i.col + "em",
          height: i.row + "em"
        }).on("mouseup", i.itemClick).on("mousemove", function(o) {
          Ni(o, i.col, i.row);
        });
      }
    }
  ).render();
}, me = I.create('<div class="note-color-palette"></div>', function(i, t) {
  const e = [];
  for (let o = 0, n = t.colors.length; o < n; o++) {
    const s = t.eventName, a = t.colors[o], c = t.colorsName[o], d = [];
    for (let h = 0, u = a.length; h < u; h++) {
      const p = a[h], k = c[h];
      d.push(
        [
          '<button type="button" class="note-btn note-color-btn"',
          'style="background-color:',
          p,
          '" ',
          'data-event="',
          s,
          '" ',
          'data-value="',
          p,
          '" ',
          'data-title="',
          k,
          '" ',
          'aria-label="',
          k,
          '" ',
          'data-toggle="button" tabindex="-1"></button>'
        ].join("")
      );
    }
    e.push('<div class="note-color-row">' + d.join("") + "</div>");
  }
  i.html(e.join("")), i.find(".note-color-btn").each(function() {
    t.container && l(t.container).length ? l(this).data(
      "_lite_tooltip",
      new fe(l(this), {
        container: t.container
      })
    ) : console.warn("Summernote: Tooltip container not found, skipping tooltip initialization for color buttons");
  });
}), Ii = function(i, t) {
  return W({
    className: "note-color",
    children: [
      q({
        className: "note-current-color-button",
        contents: i.title,
        tooltip: i.lang.color.recent,
        click: i.currentClick,
        callback: function(e) {
          const o = e.find(".note-recent-color");
          t !== "foreColor" && (o.css("background-color", "#FFFF00"), e.attr("data-backColor", "#FFFF00"));
        }
      }),
      q({
        className: "dropdown-toggle",
        contents: V("note-icon-caret"),
        tooltip: i.lang.color.more,
        data: {
          toggle: "dropdown"
        }
      }),
      it({
        items: [
          "<div>",
          '<div class="note-btn-group btn-background-color">',
          '<div class="note-palette-title">' + i.lang.color.background + "</div>",
          "<div>",
          '<button type="button" class="note-color-reset note-btn note-btn-block" data-event="backColor" data-value="transparent">',
          i.lang.color.transparent,
          "</button>",
          "</div>",
          '<div class="note-holder" data-event="backColor"></div>',
          '<div class="btn-sm">',
          '<input type="color" id="html5bcp" class="note-btn btn-default" value="#21104A" style="width:100%;" data-value="cp">',
          '<button type="button" class="note-color-reset btn" data-event="backColor" data-value="cpbackColor">',
          i.lang.color.cpSelect,
          "</button>",
          "</div>",
          "</div>",
          '<div class="note-btn-group btn-foreground-color">',
          '<div class="note-palette-title">' + i.lang.color.foreground + "</div>",
          "<div>",
          '<button type="button" class="note-color-reset note-btn note-btn-block" data-event="removeFormat" data-value="foreColor">',
          i.lang.color.resetToDefault,
          "</button>",
          "</div>",
          '<div class="note-holder" data-event="foreColor"></div>',
          '<div class="btn-sm">',
          '<input type="color" id="html5fcp" class="note-btn btn-default" value="#21104A" style="width:100%;" data-value="cp">',
          '<button type="button" class="note-color-reset btn" data-event="foreColor" data-value="cpforeColor">',
          i.lang.color.cpSelect,
          "</button>",
          "</div>",
          "</div>",
          "</div>"
        ].join(""),
        callback: function(e) {
          e.find(".note-holder").each(function() {
            const o = l(this);
            o.append(
              me({
                colors: i.colors,
                eventName: o.data("event")
              }).render()
            );
          }), t === "fore" ? (e.find(".btn-background-color").hide(), e.css({ "min-width": "210px" })) : t === "back" && (e.find(".btn-foreground-color").hide(), e.css({ "min-width": "210px" }));
        },
        click: function(e) {
          const o = l(e.target), n = o.data("event");
          let s = o.data("value");
          const a = document.getElementById("html5fcp").value, c = document.getElementById("html5bcp").value;
          if (s === "cp" ? e.stopPropagation() : s === "cpbackColor" ? s = c : s === "cpforeColor" && (s = a), n && s) {
            const d = n === "backColor" ? "background-color" : "color", h = o.closest(".note-color").find(".note-recent-color"), u = o.closest(".note-color").find(".note-current-color-button");
            h.css(d, s), u.attr("data-" + n, s), t === "fore" ? i.itemClick("foreColor", s) : t === "back" ? i.itemClick("backColor", s) : i.itemClick(n, s);
          }
        }
      })
    ]
  }).render();
}, ht = I.create(
  '<div class="note-modal" aria-hidden="false" tabindex="-1" role="dialog"></div>',
  function(i, t) {
    t.fade && i.addClass("fade"), i.attr({
      "aria-label": t.title
    }), i.html(
      [
        '<div class="note-modal-content">',
        t.title ? '<div class="note-modal-header"><button type="button" class="close" aria-label="Close" aria-hidden="true"><i class="note-icon-close"></i></button><h4 class="note-modal-title">' + t.title + "</h4></div>" : "",
        '<div class="note-modal-body">' + t.body + "</div>",
        t.footer ? '<div class="note-modal-footer">' + t.footer + "</div>" : "",
        "</div>"
      ].join("")
    ), i.data("modal", new yi(i, t));
  }
), Pi = function(i) {
  const t = '<div class="note-form-group"><label for="note-dialog-video-url-' + i.id + '" class="note-form-label">' + i.lang.video.url + ' <small class="text-muted">' + i.lang.video.providers + '</small></label><input id="note-dialog-video-url-' + i.id + '" class="note-video-url note-input" type="text"/></div>', e = [
    '<button type="button" href="#" class="note-btn note-btn-primary note-video-btn disabled" disabled>',
    i.lang.video.insert,
    "</button>"
  ].join("");
  return ht({
    title: i.lang.video.insert,
    fade: i.fade,
    body: t,
    footer: e
  }).render();
}, Ai = function(i) {
  const t = '<div class="note-form-group note-group-select-from-files"><label for="note-dialog-image-file-' + i.id + '" class="note-form-label">' + i.lang.image.selectFromFiles + '</label><input id="note-dialog-image-file-' + i.id + '" class="note-note-image-input note-input" type="file" name="files" accept="image/*" multiple="multiple"/>' + i.imageLimitation + '</div><div class="note-form-group"><label for="note-dialog-image-url-' + i.id + '" class="note-form-label">' + i.lang.image.url + '</label><input id="note-dialog-image-url-' + i.id + '" class="note-image-url note-input" type="text"/></div>', e = [
    '<button href="#" type="button" class="note-btn note-btn-primary note-btn-large note-image-btn disabled" disabled>',
    i.lang.image.insert,
    "</button>"
  ].join("");
  return ht({
    title: i.lang.image.insert,
    fade: i.fade,
    body: t,
    footer: e
  }).render();
}, Li = function(i) {
  const t = '<div class="note-form-group"><label for="note-dialog-link-txt-' + i.id + '" class="note-form-label">' + i.lang.link.textToDisplay + '</label><input id="note-dialog-link-txt-' + i.id + '" class="note-link-text note-input" type="text"/></div><div class="note-form-group"><label for="note-dialog-link-url-' + i.id + '" class="note-form-label">' + i.lang.link.url + '</label><input id="note-dialog-link-url-' + i.id + '" class="note-link-url note-input" type="text" value="http://"/></div>' + (i.disableLinkTarget ? "" : '<div class="checkbox"><label for="note-dialog-link-nw-' + i.id + '"><input id="note-dialog-link-nw-' + i.id + '" type="checkbox" checked> ' + i.lang.link.openInNewWindow + "</label></div>"), e = [
    '<button href="#" type="button" class="note-btn note-btn-primary note-link-btn disabled" disabled>',
    i.lang.link.insert,
    "</button>"
  ].join("");
  return ht({
    className: "link-dialog",
    title: i.lang.link.insert,
    fade: i.fade,
    body: t,
    footer: e
  }).render();
}, Fi = I.create(
  [
    '<div class="note-popover bottom">',
    '<div class="note-popover-arrow"></div>',
    '<div class="popover-content note-children-container"></div>',
    "</div>"
  ].join(""),
  function(i, t) {
    const e = typeof t.direction < "u" ? t.direction : "bottom";
    i.addClass(e).hide(), t.hideArrow && i.find(".note-popover-arrow").hide();
  }
), Di = I.create('<div class="checkbox"></div>', function(i, t) {
  i.html(
    [
      "<label" + (t.id ? ' for="note-' + t.id + '"' : "") + ">",
      '<input role="checkbox" type="checkbox"' + (t.id ? ' id="note-' + t.id + '"' : ""),
      t.checked ? " checked" : "",
      ' aria-checked="' + (t.checked ? "true" : "false") + '"/>',
      t.text ? t.text : "",
      "</label>"
    ].join("")
  );
}), V = function(i, t) {
  return i.match(/^</) ? i : (t = t || "i", "<" + t + ' class="' + i + '"></' + t + ">");
}, Hi = function(i) {
  return {
    editor: bt,
    toolbar: vt,
    editingArea: nt,
    codable: st,
    editable: kt,
    statusbar: Ct,
    airEditor: Kt,
    airEditable: Vt,
    buttonGroup: W,
    button: (t) => q({
      ...t,
      container: t.container || i.container
    }),
    dropdown: it,
    dropdownCheck: pe,
    dropdownButton: $i,
    dropdownButtonContents: Si,
    dropdownCheckButton: Ti,
    paragraphDropdownButton: Ei,
    tableDropdownButton: Ri,
    colorDropdownButton: Ii,
    palette: me,
    dialog: ht,
    videoDialog: Pi,
    imageDialog: Ai,
    linkDialog: Li,
    popover: Fi,
    checkbox: Di,
    icon: V,
    options: i,
    toggleBtn: function(t, e) {
      t.toggleClass("disabled", !e), t.attr("disabled", !e);
    },
    toggleBtnActive: function(t, e) {
      t.toggleClass("active", e);
    },
    check: function(t, e) {
      t.find(".checked").removeClass("checked"), t.find('[data-value="' + e + '"]').addClass("checked");
    },
    onDialogShown: function(t, e) {
      t.one("note.modal.show", e);
    },
    onDialogHidden: function(t, e) {
      t.one("note.modal.hide", e);
    },
    showDialog: function(t) {
      t.data("modal").show();
    },
    hideDialog: function(t) {
      t.data("modal").hide();
    },
    /**
     * get popover content area
     *
     * @param $popover
     * @returns {*}
     */
    getPopoverContent: function(t) {
      return t.find(".note-popover-content");
    },
    /**
     * get dialog's body area
     *
     * @param $dialog
     * @returns {*}
     */
    getDialogBody: function(t) {
      return t.find(".note-modal-body");
    },
    createLayout: function(t) {
      const e = (i.airMode ? Kt([nt([st(), Vt()])]) : i.toolbarPosition === "bottom" ? bt([nt([st(), kt()]), vt(), Ct()]) : bt([vt(), nt([st(), kt()]), Ct()])).render();
      return e.insertAfter(t), {
        note: t,
        editor: e,
        toolbar: e.find(".note-toolbar"),
        editingArea: e.find(".note-editing-area"),
        editable: e.find(".note-editable"),
        codable: e.find(".note-codable"),
        statusbar: e.find(".note-statusbar")
      };
    },
    removeLayout: function(t, e) {
      t.html(e.editable.html()), e.editor.remove(), t.off("summernote"), t.show();
    }
  };
};
l.summernote = l.extend(l.summernote, {
  ui_template: Hi,
  interface: "lite"
});
//# sourceMappingURL=summernote-lite.min.js.map
